{"version":3,"file":"pag.min.js","sources":["../src/base/utils/error-map.ts","../src/base/utils/log.ts","../src/codec/types.ts","../src/codec/tags/tag-header.ts","../src/constant.ts","../src/base/color.ts","../src/base/utils/verify.ts","../src/base/composition.ts","../src/base/video-composition.ts","../src/base/ratio.ts","../src/base/point.ts","../src/base/layer.ts","../src/base/mask.ts","../src/codec/data-types.ts","../src/codec/tags/composition-attributes.ts","../src/base/video-frame.ts","../src/base/sequence.ts","../src/base/video-sequence.ts","../src/base/byte-data.ts","../src/codec/context.ts","../src/codec/utils/byte-array.ts","../src/codec/utils/byte-utils.ts","../src/codec/nalu-start-code.ts","../src/codec/tags/video-composition-tag.ts","../src/codec/tags/video-sequence-tag.ts","../src/base/effects/effect.ts","../src/codec/attribute-helper.ts","../src/base/time-range.ts","../src/base/vector-composition.ts","../src/base/property.ts","../src/base/transform-2d.ts","../src/base/pre-compose-layer.ts","../src/base/shape-layer.ts","../src/base/solid-layer.ts","../src/base/un-defined-layer.ts","../src/base/keyframe.ts","../src/base/animatable-property.ts","../src/base/utils/interpolate.ts","../src/base/utils/interpolator.ts","../src/base/keyframes/multi-dimension-point-keyframe.ts","../src/base/keyframes/single-ease-keyframe.ts","../src/codec/attributes.ts","../src/codec/tags/tag-attributes.ts","../src/codec/tags/layer-tag.ts","../src/codec/tags/solid-layer.ts","../src/codec/tags/read-composition-reference.ts","../src/codec/tags/vector-composition-tag.ts","../src/codec/tags/file-tags.ts","../src/file/video-data.ts","../src/generator/nalu.ts","../src/generator/exp-golomb.ts","../src/generator/h264-parser.ts","../src/generator/mp4-generator.ts","../src/generator/h264-remuxer.ts","../src/pag-generator.ts","../src/view/types.ts","../src/pag-file.ts","../src/file/utils.ts","../src/base/utils/http-request.ts","../src/pag-codec.ts","../src/view/utils.ts","../src/view/shader.ts","../src/base/utils/event-manager.ts","../src/pag-view.ts"],"sourcesContent":["export enum ErrorCode {\n  InputError,\n  LoadFileByXhrError,\n  LoadFileNotResponse,\n  ReadPagFileError,\n  PagFileLengthErrorTooShort,\n  InvalidPagFileHeader,\n  NotByteArray,\n  PagCodecError,\n  ReadStartCodeError,\n  NotPagFile,\n  NotVideoData,\n  NotMp4File,\n  NotSequence,\n  NotNalu,\n  NotFrames,\n  NotPayloadOnRemuxer,\n  NotSupportMSE,\n  NotSupportMultipleSequence,\n  PagDestroyed,\n  InvalidPercentage,\n  WriteFileFile,\n}\n\nexport const ErrorMap = {\n  [ErrorCode.InputError]: '请URL或者上传的PAG文件是否正确！',\n  [ErrorCode.LoadFileByXhrError]: '加载PAG文件网络请求错误！',\n  [ErrorCode.LoadFileNotResponse]: '加载PAG文件内容为空!',\n  [ErrorCode.ReadPagFileError]: '读取PAG文件错误！',\n  [ErrorCode.PagFileLengthErrorTooShort]: 'PAG文件长度太短!',\n  [ErrorCode.InvalidPagFileHeader]: '无效的PAG文件头部!',\n  [ErrorCode.NotByteArray]: '文件中字节流不存在!',\n  [ErrorCode.PagCodecError]: 'PAG解码错误!',\n  [ErrorCode.ReadStartCodeError]: '读取StartCode错误!',\n  [ErrorCode.NotPagFile]: 'PAG文件不存在！',\n  [ErrorCode.NotVideoData]: 'VideoData不存在！',\n  [ErrorCode.NotMp4File]: 'MP4文件不存在！',\n  [ErrorCode.NotSequence]: '视频序列帧不存在！',\n  [ErrorCode.NotNalu]: '视频序列帧上Nalu不存在！',\n  [ErrorCode.NotFrames]: '视频序列帧上Frame不存在！',\n  [ErrorCode.NotPayloadOnRemuxer]: 'Remuxer上不存在Payload！',\n  [ErrorCode.NotSupportMSE]: '浏览器不支持MediaSourceExtension！',\n  [ErrorCode.NotSupportMultipleSequence]: '暂不支持多sequence的PAG文件！',\n  [ErrorCode.PagDestroyed]: '该PAG已经销毁！',\n  [ErrorCode.InvalidPercentage]: '无效百分比!',\n  [ErrorCode.WriteFileFile]: '写入文件失败',\n};\n","import { ErrorCode, ErrorMap } from './error-map';\n\nexport class Log {\n  public static log(message) {\n    console.log(message);\n  }\n  public static error(errorCode: ErrorCode) {\n    throw new Error(ErrorMap[errorCode]);\n  }\n}\n","export const enum CompositionType {\n  Unknown,\n  Vector,\n  Bitmap,\n  Video,\n}\n\nexport const enum TagCode {\n  End = 0,\n  FontTables = 1,\n  VectorCompositionBlock = 2,\n  CompositionAttributes = 3,\n  ImageTables = 4,\n  LayerBlock = 5,\n  LayerAttributes = 6,\n  SolidColor = 7,\n  TextSource = 8,\n  TextPathOption = 9,\n  TextMoreOption = 10,\n  ImageReference = 11,\n  CompositionReference = 12,\n  Transform2D = 13,\n  MaskBlock = 14,\n  ShapeGroup = 15,\n  Rectangle = 16,\n  Ellipse = 17,\n  PolyStar = 18,\n  ShapePath = 19,\n  Fill = 20,\n  Stroke = 21,\n  GradientFill = 22,\n  GradientStroke = 23,\n  MergePaths = 24,\n  TrimPaths = 25,\n  Repeater = 26,\n  RoundCorners = 27,\n  Performance = 28,\n  DropShadowStyle = 29,\n  InnerShadowStyle = 30,\n  OuterGlowStyle = 31,\n  InnerGlowStyle = 32,\n  BevelAndEmbossStyle = 33,\n  SatinStyle = 34,\n  ColorOverlayStyle = 35,\n  GradientOverlayStyle = 36,\n  StrokeStyle = 37,\n  TintEffect = 38,\n  FillEffect = 39,\n  StrokeEffect = 40,\n  TritoneEffect = 41,\n  DropShadowEffect = 42,\n  RadialWipeEffect = 43,\n  DisplacementMapEffect = 44,\n  BitmapCompositionBlock = 45,\n  BitmapSequence = 46,\n  ImageBytes = 47,\n  ImageBytes2 = 48,\n  ImageBytes3 = 49,\n  VideoCompositionBlock = 50,\n  VideoSequence = 51,\n  LayerAttributesV2 = 52,\n  // add new tags here...\n  Count,\n}\n","import { TagCode } from '../types';\nimport { ByteArray } from '../utils/byte-array';\n\nexport interface TagHeader {\n  code: TagCode;\n  length: number;\n}\n\nexport const readTagHeader = (byteBuffer: ByteArray): TagHeader => {\n  const codeAndLength: number = byteBuffer.readUint16();\n  let length: number = (codeAndLength & 63) >>> 0;\n  const code: number = codeAndLength >> 6;\n  if (length === 63) {\n    length = byteBuffer.readUint32();\n  }\n  if (byteBuffer.context.tagLevel < code) {\n    byteBuffer.context.tagLevel = code;\n  }\n  return { code, length };\n};\n\nexport function readTags<T>(byteArray: ByteArray, parameter: T, reader: Function) {\n  let header = readTagHeader(byteArray);\n  while (header.code !== TagCode.End) {\n    const tagBytes = byteArray.readBytes(header.length);\n    reader(tagBytes, header.code, parameter);\n    if (byteArray.context.tagLevel < tagBytes.context.tagLevel) {\n      byteArray.context.tagLevel = tagBytes.context.tagLevel;\n    }\n    header = readTagHeader(byteArray);\n  }\n}\n","export const ZERO_ID = 0;\nexport const ZERO_TIME = 0;\nexport const OPAQUE = 255;\nexport const TRANSPARENT = 0;\n\n// 混合模式\nexport const enum BlendMode {\n  Normal = 0,\n  Multiply = 1,\n  Screen = 2,\n  Overlay = 3,\n  Darken = 4,\n  Lighten = 5,\n  ColorDodge = 6,\n  ColorBurn = 7,\n  HardLight = 8,\n  SoftLight = 9,\n  Difference = 10,\n  Exclusion = 11,\n  Hue = 12,\n  Saturation = 13,\n  Color = 14,\n  Luminosity = 15,\n\n  // modes used only when rendering.\n  DestinationIn = 21,\n  DestinationOut = 22,\n  DestinationATop = 23,\n  SourceIn = 24,\n  SourceOut = 25,\n  Xor = 26,\n}\n\n// 路径动作\nexport const enum PathVerb {\n  MoveTo,\n  LineTo,\n  CurveTo,\n  Close,\n}\n\n// 关键帧的差值器类型\nexport const enum KeyframeInterpolationType {\n  None = 0,\n  Linear = 1,\n  Bezier = 2,\n  Hold = 3,\n}\n\n// 段落对齐\nexport const enum ParagraphJustification {\n  LeftJustify = 0,\n  CenterJustify = 1,\n  RightJustify = 2,\n  FullJustifyLastLineLeft = 3,\n  FullJustifyLastLineRight = 4,\n  FullJustifyLastLineCenter = 5,\n  FullJustifyLastLineFull = 6,\n}\n","export interface Color {\n  red: number; // in the range [0 - 255]\n  green: number;\n  blue: number;\n}\n\nexport const Black: Color = { red: 0, green: 0, blue: 0 };\nexport const White: Color = { red: 255, green: 255, blue: 255 };\nexport const Red: Color = { red: 255, green: 0, blue: 0 };\nexport const Green: Color = { red: 0, green: 255, blue: 0 };\nexport const Blue: Color = { red: 0, green: 0, blue: 255 };\n","import { Log } from './log';\n\nexport const verifyFailed = () => {\n  Log.log('PAG Verify Failed!');\n};\n\nexport const verifyAndrReturn = (expression): boolean => {\n  if (expression) {\n    return true;\n  }\n  Log.log('PAG Verify Failed!');\n  return false;\n};\n","import { ZERO_ID, ZERO_TIME } from '../constant';\nimport { Color, White } from './color';\nimport { CompositionType } from '../codec/types';\nimport { TimeRange } from './time-range';\nimport { verifyAndrReturn } from './utils/verify';\n\nexport class Composition {\n  private static cacheIDCount = 1;\n\n  /**\n   * A unique identifier for this item.\n   */\n  public id: number = ZERO_ID;\n  /**\n   * The width of the Composition.\n   */\n  public width = 0;\n  /**\n   * The height of the item.\n   */\n  public height = 0;\n  /**\n   * The total duration of the item.\n   */\n  public duration: number = ZERO_TIME;\n  /**\n   * The frame rate of the Composition.\n   */\n  public frameRate = 30;\n  /**\n   * The background color of the composition.\n   */\n  public backgroundColor: Color = White;\n  public cacheID = 0;\n\n  public constructor() {\n    this.cacheID = Composition.cacheIDCount;\n    Composition.cacheIDCount += 1;\n  }\n\n  /**\n   * The type of the Composition.\n   */\n  public type(): CompositionType {\n    return CompositionType.Unknown;\n  }\n\n  /**\n   * Returns the static time ranges of this composition.\n   */\n  public getStaticTimeRanges(): Array<TimeRange> {\n    return undefined;\n  }\n\n  public verify(): boolean {\n    return verifyAndrReturn(this.width > 0 && this.height > 0 && this.duration > 0 && this.frameRate > 0);\n  }\n}\n","import { Composition } from './composition';\nimport { CompositionType } from '../codec/types';\nimport { TimeRange } from './time-range';\nimport { VideoSequence } from './video-sequence';\nimport { verifyFailed } from './utils/verify';\n\nexport class VideoComposition extends Composition {\n  public hasAlpha = false;\n  public sequences: Array<VideoSequence> = [];\n\n  private staticTimeRanges: Array<TimeRange> = [];\n  private staticTimeRangeUpdated = false;\n\n  public type(): CompositionType {\n    return CompositionType.Video;\n  }\n\n  public getStaticTimeRanges(): Array<TimeRange> {\n    if (!this.staticTimeRangeUpdated) {\n      this.staticTimeRangeUpdated = true;\n      this.updateStaticTimeRanges();\n    }\n    return this.staticTimeRanges;\n  }\n\n  public updateStaticTimeRanges(): void {\n    if (this.duration <= 1) return;\n    if (this.sequences.length > 0) {\n      let sequence = this.sequences[0];\n      for (let i = 1; i < this.sequences.length; i++) {\n        const item = this.sequences[i];\n        if (item.frameRate > sequence.frameRate) sequence = item;\n      }\n      const timeScale = this.frameRate / sequence.frameRate;\n      for (const timeRange of sequence.staticTimeRanges) {\n        timeRange.start = Math.round(timeRange.start * timeScale);\n        timeRange.end = Math.round(timeRange.end * timeScale);\n        this.staticTimeRanges.push(timeRange);\n      }\n    } else {\n      const range: TimeRange = { start: 0, end: this.duration - 1 };\n      this.staticTimeRanges.push(range);\n    }\n  }\n\n  public hasImageContent(): boolean {\n    return true;\n  }\n\n  public verify(): boolean {\n    if (!super.verify() || this.sequences.length <= 0) {\n      verifyFailed();\n      return false;\n    }\n    for (const sequence of this.sequences) {\n      if (!sequence || !sequence.verify()) {\n        verifyFailed();\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","export class Ratio {\n  public numerator = 1;\n  public denominator = 1;\n\n  constructor(numerator: number, denominator: number) {\n    this.numerator = numerator;\n    this.denominator = denominator;\n  }\n\n  public value(): number {\n    return this.numerator / this.denominator;\n  }\n}\n\nexport const DefaultRatio = new Ratio(1, 1);\n","export class Point {\n  public x: number;\n  public y: number;\n  public constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nexport const ZERO_POINT = new Point(0, 0);\n","import { TimeRange } from './time-range';\nimport { VectorComposition } from './vector-composition';\nimport { Ratio, DefaultRatio } from './ratio';\nimport { BlendMode, ZERO_ID, ZERO_TIME } from '../constant';\nimport { Transform2D } from './transform-2d';\nimport { Property } from './property';\nimport { Mask } from './mask';\nimport { Effect } from './effects/effect';\nimport { Point } from './point';\nimport { verifyFailed } from './utils/verify';\nimport { AnimatableProperty } from './animatable-property';\n\nexport const enum LayerStyleType {\n  Unknown,\n  DropShadow,\n  Stroke,\n}\n\nexport class LayerStyle {\n  public type(): LayerStyleType {\n    return LayerStyleType.Unknown;\n  }\n\n  public excludeVaryingRanges(_timeRanges: Array<TimeRange>): void {}\n\n  public gotoFrame(_time: number): void {}\n\n  public verify(): boolean {\n    return false;\n  }\n}\n\nexport const enum TrackMatteType {\n  None = 0,\n  Alpha = 1,\n  AlphaInverted = 2,\n  Luma = 3,\n  LumaInverted = 4,\n}\n\nexport const enum LayerType {\n  Unknown,\n  undefined,\n  Solid,\n  Text,\n  Shape,\n  Image,\n  PreCompose,\n}\n\nexport class Layer {\n  /**\n   * Te id of the layer.\n   */\n  public id = 0;\n  /**\n   * The parent of this layer.\n   */\n  public parent: Layer = undefined; // layer reference\n\n  public containingComposition: VectorComposition = undefined; // composition reference\n\n  /**\n   * The time stretch percentage of the layer.\n   */\n  public stretch: Ratio = DefaultRatio;\n  /**\n   * The start time of the layer, indicates the start position of the visible range. It could be a negative value.\n   */\n  startTime: number = ZERO_ID;\n  /**\n   * The duration of the layer, indicates the length of the visible range.\n   */\n  public duration: number = ZERO_TIME;\n  /**\n   * When true, the layer' automatic orientation is enabled.\n   */\n  public autoOrientation = false;\n  /**\n   * The transformation of the layer.\n   */\n  public transform: Transform2D = undefined;\n  /**\n   * When false, the layer should be skipped during the rendering loop.\n   */\n  public isActive = true;\n  /**\n   * The blending mode of the layer.\n   */\n  public blendMode: BlendMode = BlendMode.Normal;\n  /**\n   * If layer has a track matte, specifies the way it is applied.\n   */\n  public trackMatteType: TrackMatteType = TrackMatteType.None;\n  public trackMatteLayer: Layer = undefined;\n  public timeRemap: Property<number> = undefined;\n  public masks: Array<Mask> = undefined;\n  public effects: Array<Effect> = undefined;\n  public layerStyles: Array<LayerStyle> = undefined;\n\n  public layerCache: Cache = undefined;\n\n  private maxScale: Point = undefined;\n\n  public type(): LayerType {\n    return LayerType.Unknown;\n  }\n\n  public excludeVaryingRanges(timeRanges: Array<TimeRange>): void {\n    this.transform.excludeVaryingRanges(timeRanges);\n    if (this.timeRemap !== undefined) {\n      this.timeRemap.excludeVaryingRanges(timeRanges);\n    }\n    if (this.masks !== undefined) {\n      for (const mask of this.masks) {\n        mask.excludeVaryingRanges(timeRanges);\n      }\n    }\n    if (this.effects !== undefined && this.effects.length > 0) {\n      for (const effect of this.effects) {\n        effect.excludeVaryingRanges(timeRanges);\n      }\n    }\n    if (this.layerStyles !== undefined && this.layerStyles.length > 0) {\n      for (const layerStyle of this.layerStyles) {\n        layerStyle.excludeVaryingRanges(timeRanges);\n      }\n    }\n  }\n\n  public gotoFrame(frame: number): void {\n    this.transform.gotoFrame(frame);\n    if (this.timeRemap !== undefined) {\n      this.timeRemap.gotoFrame(frame);\n    }\n    if (this.masks !== undefined && this.masks.length > 0) {\n      for (const mask of this.masks) {\n        mask.gotoFrame(frame);\n      }\n    }\n    if (this.effects !== undefined && this.effects.length > 0) {\n      for (const effect of this.effects) {\n        effect.gotoFrame(frame);\n      }\n    }\n    if (this.layerStyles !== undefined && this.layerStyles.length > 0) {\n      for (const layerStyle of this.layerStyles) {\n        layerStyle.gotoFrame(frame);\n      }\n    }\n  }\n\n  public verify(): boolean {\n    if (!this.containingComposition || this.duration <= 0 || !this.transform) {\n      verifyFailed();\n      return false;\n    }\n    if (!this.transform.verify()) {\n      verifyFailed();\n      return false;\n    }\n    if (this.masks && this.masks.length > 0) {\n      for (const mask of this.masks) {\n        if (!mask || !mask.verify()) {\n          verifyFailed();\n          return false;\n        }\n      }\n    }\n\n    if (this.layerStyles && this.layerStyles.length > 0) {\n      for (const layerStyle of this.layerStyles) {\n        if (!layerStyle || !layerStyle.verify()) {\n          verifyFailed();\n          return false;\n        }\n      }\n    }\n\n    if (this.effects && this.effects.length > 0) {\n      for (const effect of this.effects) {\n        if (!effect || !effect.verify()) {\n          verifyFailed();\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  public getMaxScaleFactor(): Point {\n    if (this.maxScale !== undefined) {\n      return this.maxScale;\n    }\n    this.maxScale = new Point(1, 1);\n    const property = this.transform.scale;\n    if (property.animatable()) {\n      const { keyframes } = property as AnimatableProperty<Point>;\n      let scaleX = Math.abs(keyframes[0].startValue.x);\n      let scaleY = Math.abs(keyframes[0].startValue.y);\n      if (keyframes !== undefined && keyframes.length > 0) {\n        for (const keyframe of keyframes) {\n          const x = Math.abs(keyframe.endValue.x);\n          const y = Math.abs(keyframe.endValue.y);\n          if (scaleX < x) {\n            scaleX = x;\n          }\n          if (scaleY < y) {\n            scaleY = y;\n          }\n        }\n      }\n      this.maxScale.x = scaleX;\n      this.maxScale.y = scaleY;\n    } else {\n      this.maxScale.x = Math.abs(property.value.x);\n      this.maxScale.y = Math.abs(property.value.y);\n    }\n    if (this.parent !== undefined) {\n      const parentScale = this.parent.getMaxScaleFactor();\n      this.maxScale.x *= parentScale.x;\n      this.maxScale.y *= parentScale.y;\n    }\n    return this.maxScale;\n  }\n}\n","import { ZERO_ID } from '../constant';\nimport { Path } from './path';\nimport { Property } from './property';\nimport { TimeRange } from './time-range';\n\nexport const enum MaskMode {\n  None = 0,\n  Add = 1,\n  Subtract = 2,\n  Intersect = 3,\n  Lighten = 4,\n  Darken = 5,\n  Difference = 6,\n  Accum = 7,\n}\n\nexport class Mask {\n  public id: number = ZERO_ID;\n  public inverted = false;\n  public maskMode: MaskMode.None;\n  public maskPath: Property<Path> = undefined;\n  public maskOpacity: Property<number> = undefined;\n  public maskExpansion: Property<number> = undefined;\n\n  public excludeVaryingRanges(_timeRanges: Array<TimeRange>): void {}\n\n  public gotoFrame(_frame: number): void {}\n\n  public verify(): boolean {\n    return false;\n  }\n}\n","import { Color } from '../base/color';\nimport { Composition } from '../base/composition';\nimport { Ratio } from '../base/ratio';\nimport { ByteArray } from './utils/byte-array';\nimport { Point } from '../base/point';\nimport { Layer } from '../base/layer';\nimport { Mask } from '../base/mask';\n\nexport const SPATIAL_PRECISION = 0.05;\nexport const BEZIER_PRECISION = 0.005;\n\nexport const readRatio = (byteArray: ByteArray): Ratio => {\n  const numeratorValue: number = byteArray.readEncodeInt32();\n  const denominatorValue: number = byteArray.readEncodedUint32();\n  const ration: Ratio = new Ratio(numeratorValue, denominatorValue);\n  return ration;\n};\n\nexport const readColor = (byteArray: ByteArray): Color => {\n  const redNum: number = byteArray.readUint8();\n  const greenNum: number = byteArray.readUint8();\n  const blueNum: number = byteArray.readUint8();\n  const color: Color = { red: redNum, green: greenNum, blue: blueNum };\n  return color;\n};\n\nexport const readTime = (byteArray: ByteArray): number => byteArray.readEncodedUint64();\n\nexport const readFloat = (byteArray: ByteArray): number => byteArray.readFloat32();\n\nexport const readBoolean = (byteArray: ByteArray): boolean => byteArray.readBitBoolean();\n\nexport const readEnum = (byteArray: ByteArray): number => byteArray.readUint8();\n\nexport const readID = (byteArray: ByteArray): number => byteArray.readEncodedUint32();\n\nexport const readLayerID = (byteArray: ByteArray): Layer => {\n  const id: number = byteArray.readEncodedUint32();\n  if (id > 0) {\n    const layer: Layer = new Layer();\n    layer.id = id;\n    return layer;\n  }\n  return undefined;\n};\n\nexport const readMaskID = (byteArray: ByteArray): Mask => {\n  const id: number = byteArray.readEncodedUint32();\n  if (id > 0) {\n    const mask: Mask = new Mask();\n    mask.id = id;\n    return mask;\n  }\n  return undefined;\n};\n\nexport const readCompositionID = (byteArray: ByteArray): Composition => {\n  const id: number = byteArray.readEncodedUint32();\n  if (id > 0) {\n    const composition: Composition = new Composition();\n    composition.id = id;\n    return composition;\n  }\n  return undefined;\n};\n\nexport const readString = (byteArray: ByteArray): string => byteArray.readUTF8String();\n\nexport function ReadOpacity(byteArray: ByteArray): number {\n  return byteArray.readUint8();\n}\n\nexport const readPoint = (byteArray: ByteArray): Point => {\n  const x: number = byteArray.readFloat32();\n  const y: number = byteArray.readFloat32();\n  return new Point(x, y);\n};\n","import { Composition } from '../../base/composition';\nimport { readColor, readTime } from '../data-types';\nimport { ByteArray } from '../utils/byte-array';\n\nexport const readCompositionAttributes = (byteArray: ByteArray, composition: Composition) => {\n  composition.width = byteArray.readEncodeInt32();\n  composition.height = byteArray.readEncodeInt32();\n  composition.duration = readTime(byteArray);\n  composition.frameRate = byteArray.readFloat32();\n  composition.backgroundColor = readColor(byteArray);\n};\n","import { ByteData } from './byte-data';\n\nexport class VideoFrame {\n  public isKeyframe = false;\n  public frame = 0;\n  public fileBytes: ByteData = undefined;\n}\n","import { Composition } from './composition';\nimport { verifyAndrReturn } from './utils/verify';\n\nexport class Sequence {\n  public composition: Composition = undefined;\n  public id = 0;\n  public width = 0;\n  public height = 0;\n  public frameRate = 0;\n  public frameCount = 0;\n  public isKeyFrameFlags: Array<boolean> = [];\n\n  public verify() {\n    return verifyAndrReturn(this.composition !== undefined && this.width > 0 && this.height > 0 && this.frameRate > 0);\n  }\n}\n","import { ByteData } from './byte-data';\nimport { Sequence } from './sequence';\nimport { TimeRange } from './time-range';\nimport { verifyFailed } from './utils/verify';\nimport { VideoFrame } from './video-frame';\n\nexport class VideoSequence extends Sequence {\n  public alphaStartX = 0;\n  public alphaStartY = 0;\n  public frames: Array<VideoFrame> = [];\n  public headers: Array<ByteData> = [];\n  public staticTimeRanges: Array<TimeRange> = [];\n\n  public verify(): boolean {\n    if (!super.verify() || this.frames.length <= 0) {\n      verifyFailed();\n      return false;\n    }\n    for (const frame of this.frames) {\n      if (!frame && !frame.fileBytes) {\n        verifyFailed();\n        return false;\n      }\n    }\n    for (const header of this.headers) {\n      if (!header) {\n        verifyFailed();\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","import { ByteArray } from '../codec/utils/byte-array';\n\nexport class ByteData {\n  public data: ByteArray = undefined;\n  public length = 0;\n\n  constructor(data: ByteArray, length: number) {\n    this.data = data;\n    this.length = length;\n  }\n}\n","import { Composition } from '../base/composition';\nimport { ImageBytes } from '../base/image-bytes';\n\nexport class Context {\n  public tagLevel = 0;\n  public compositions: Array<Composition> = [];\n  public images: Array<ImageBytes> = [];\n\n  private errorMessages: string[] = [];\n\n  public throwException(message: string) {\n    this.errorMessages.push(message);\n  }\n\n  public releaseCompositions(): Array<Composition> {\n    const compositions = this.compositions.slice();\n    this.compositions = undefined;\n    return compositions;\n  }\n\n  public releaseImages(): Array<ImageBytes> {\n    const images = this.images.slice();\n    this.images = undefined;\n    return images;\n  }\n}\n","import { ErrorCode } from '../../base/utils/error-map';\nimport { Log } from '../../base/utils/log';\nimport { Context } from '../context';\n\nconst LENGTH_FOR_STORE_NUM_BITS = 5;\n\nexport class ByteArray {\n  public context: Context;\n\n  private readonly littleEndian: boolean;\n  private dataView: DataView;\n  private position = 0;\n  private bitPosition = 0;\n\n  constructor(buffer: ArrayBuffer, littleEndian?: boolean) {\n    this.dataView = new DataView(buffer);\n    this.littleEndian = !!littleEndian;\n    this.context = new Context();\n  }\n\n  public get length(): number {\n    return this.dataView.byteLength;\n  }\n\n  public get bytesAvailable(): number {\n    return this.dataView.byteLength - this.position;\n  }\n\n  public data(): ArrayBuffer {\n    return this.dataView.buffer;\n  }\n\n  public get postion(): number {\n    return this.position;\n  }\n\n  public alignWithBytes() {\n    this.bitPosition = this.position * 8;\n  }\n\n  public readBoolean(): boolean {\n    const value = this.dataView.getInt8(this.position);\n    this.position += 1;\n    this.positonChangend();\n    return Boolean(value);\n  }\n\n  public readChar(): string {\n    if (this.position >= this.length) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getInt8(this.position);\n    this.position += 1;\n    this.positonChangend();\n    return String.fromCharCode(value);\n  }\n\n  public readUint8(): number {\n    if (this.position >= this.length) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getUint8(this.position);\n    this.position += 1;\n    this.positonChangend();\n    return value;\n  }\n\n  public readInt8(): number {\n    if (this.position >= this.length) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getInt8(this.position);\n    this.position += 1;\n    this.positonChangend();\n    return value;\n  }\n\n  public readInt16(): number {\n    if (this.position >= this.length - 1) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getInt16(this.position, this.littleEndian);\n    this.position += 2;\n    this.positonChangend();\n    return value;\n  }\n\n  public readUint16(): number {\n    if (this.position >= this.length - 1) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getUint16(this.position, this.littleEndian);\n    this.position += 2;\n    this.positonChangend();\n    return value;\n  }\n\n  public readInt24(): number {\n    if (this.position >= this.length - 2) Log.error(ErrorCode.PagCodecError);\n    const left = this.dataView.getInt16(this.position, this.littleEndian);\n    const right = this.dataView.getInt8(this.position + 2);\n    this.position += 3;\n    this.positonChangend();\n    return this.littleEndian ? left + 2 ** 16 * right : 2 ** 16 * left + right;\n  }\n\n  public readUint24(): number {\n    if (this.position >= this.length - 2) Log.error(ErrorCode.PagCodecError);\n    const left = this.dataView.getUint16(this.position, this.littleEndian);\n    const right = this.dataView.getUint8(this.position + 2);\n    this.position += 3;\n    this.positonChangend();\n    return this.littleEndian ? left + 2 ** 16 * right : 2 ** 16 * left + right;\n  }\n\n  public readInt32(): number {\n    if (this.position >= this.length - 3) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getInt32(this.position, this.littleEndian);\n    this.position += 4;\n    this.positonChangend();\n    return value;\n  }\n\n  public readUint32(): number {\n    if (this.position >= this.length - 3) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getUint32(this.position, this.littleEndian);\n    this.position += 4;\n    this.positonChangend();\n    return value;\n  }\n\n  public readInt64(): number {\n    if (this.position >= this.length - 7) Log.error(ErrorCode.PagCodecError);\n    const left = this.dataView.getInt32(this.position, this.littleEndian);\n    const right = this.dataView.getInt32(this.position + 4, this.littleEndian);\n    this.position += 8;\n    this.positonChangend();\n    return this.littleEndian ? left + 2 ** 32 * right : 2 ** 32 * left + right;\n  }\n\n  public readUint64(): number {\n    if (this.position >= this.length - 7) Log.error(ErrorCode.PagCodecError);\n    const left = this.dataView.getUint32(this.position, this.littleEndian);\n    const right = this.dataView.getUint32(this.position + 4, this.littleEndian);\n    this.position += 8;\n    this.positonChangend();\n    return this.littleEndian ? left + 2 ** 32 * right : 2 ** 32 * left + right;\n  }\n\n  public readFloat32(): number {\n    if (this.position >= this.length - 3) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getFloat32(this.position, this.littleEndian);\n    this.position += 4;\n    this.positonChangend();\n    return value;\n  }\n\n  public readDouble(): number {\n    if (this.position >= this.length - 7) Log.error(ErrorCode.PagCodecError);\n    const value = this.dataView.getFloat64(this.position, this.littleEndian);\n    this.position += 8;\n    this.positonChangend();\n    return value;\n  }\n\n  public readUTF8String(): string {\n    if (this.position >= this.length) Log.error(ErrorCode.PagCodecError);\n    let encoded = '';\n    let dataLength = 0;\n    for (let i = this.position; i < this.length; i++) {\n      if (this.dataView.getUint8(i) === 0) {\n        break;\n      }\n      encoded += `%${this.dataView.getUint8(i).toString(16)}`;\n      dataLength += 1;\n    }\n    this.position += dataLength;\n    this.positonChangend();\n    return decodeURIComponent(encoded);\n  }\n\n  public readEncodedUint32(): number {\n    const valueMask = 127;\n    const hasNext = 128;\n    let value = 0;\n    let byte = 0;\n    for (let i = 0; i < 32; i += 7) {\n      if (this.position >= this.length) {\n        throw Error('readEncodedUint32 End of file was encountered.');\n        break;\n      }\n      byte = this.dataView.getUint8(this.position);\n      this.position += 1;\n      value |= (byte & valueMask) << i;\n      if ((byte & hasNext) === 0) {\n        break;\n      }\n    }\n    this.positonChangend();\n    return value;\n  }\n\n  public readEncodeInt32(): number {\n    const data = this.readEncodedUint32();\n    const value = data >> 1;\n    return (data & 1) > 0 ? -value : value;\n  }\n\n  public readEncodedUint64(): number {\n    const valueMask = 127;\n    const hasNext = 128;\n    let value = 0;\n    let byte = 0;\n    for (let i = 0; i < 64; i += 7) {\n      if (this.position >= this.length) {\n        throw Error('readEncodedUint64 End of file was encountered.');\n        break;\n      }\n      byte = this.dataView.getUint8(this.position);\n      this.position += 1;\n      value |= (byte & valueMask) << i;\n      if ((byte & hasNext) === 0) {\n        break;\n      }\n    }\n    this.positonChangend();\n    return value;\n  }\n\n  public readEncodeInt64(): number {\n    const data = this.readEncodedUint64();\n    const value = data << 0;\n    return (data & 1) > 0 ? -value : value;\n  }\n\n  public readBytes(length?: number): ByteArray {\n    if (!length || length <= 0) {\n      length = this.length - this.position;\n    }\n    if (this.position > this.length - length) Log.error(ErrorCode.PagCodecError);\n    const newBuffer = this.dataView.buffer.slice(this.position, this.position + length);\n    this.position += length;\n    this.positonChangend();\n    return new ByteArray(newBuffer, this.littleEndian);\n  }\n\n  public readUBits(numBits: number): number {\n    const bitMasks: number[] = [0, 1, 3, 7, 15, 31, 63, 127, 255];\n    let value = 0;\n    if (this.bitPosition > this.length * 8 - numBits) Log.error(ErrorCode.PagCodecError);\n    let pos = 0;\n    while (pos < numBits) {\n      const bytePosition = Math.floor(this.bitPosition * 0.125);\n      const bitPosition = this.bitPosition % 8;\n      let byte = this.dataView.getUint8(bytePosition) >> bitPosition;\n      const bitLength = Math.min(8 - bitPosition, numBits - pos);\n      byte &= bitMasks[bitLength];\n      value |= byte << pos;\n      pos += bitLength;\n      this.bitPosition += bitLength;\n    }\n    this.bitPositionChanged();\n    return value;\n  }\n\n  public readBits(numBits: number): number {\n    let value = this.readUBits(numBits);\n    value <<= 32 - numBits;\n    const data = value << 0;\n    return data >> (32 - numBits);\n  }\n\n  public readNumBits(): number {\n    return this.readUBits(LENGTH_FOR_STORE_NUM_BITS) + 1;\n  }\n\n  public readInt32List(count: number): number[] {\n    const numBits = this.readNumBits();\n    const value = new Array(count);\n    for (let i = 0; i < count; i++) {\n      value[i] = this.readBits(numBits);\n    }\n    return value;\n  }\n\n  public readUint32List(count: number): number[] {\n    const numBits = this.readNumBits();\n    const value = new Array(count);\n    for (let i = 0; i < count; i++) {\n      value[i] = this.readUBits(numBits);\n    }\n    return value;\n  }\n\n  public readBitBoolean() {\n    return this.readUBits(1) !== 0;\n  }\n\n  public readFloatList(count: number, percision: number): number[] {\n    const numBits = this.readNumBits();\n    const value = new Array(count);\n    for (let i = 0; i < count; i++) {\n      value[i] = this.readBits(numBits) * percision;\n    }\n    return value;\n  }\n\n  private bitPositionChanged() {\n    this.position = Math.ceil(this.bitPosition * 0.125);\n  }\n\n  private positonChangend() {\n    this.bitPosition = this.position * 8;\n  }\n}\n","export const memcpy = (dst: ArrayBuffer, dstOffset: number, src: ArrayBuffer, srcOffset: number, num: number) => {\n  if (\n    dstOffset >= dst.byteLength ||\n    srcOffset >= src.byteLength ||\n    src.byteLength - srcOffset > dst.byteLength - dstOffset ||\n    num > src.byteLength\n  )\n    return;\n  const dstUint8Array = new Uint8Array(dst);\n  const srcUint8Array = new Uint8Array(src, srcOffset, num);\n  dstUint8Array.set(srcUint8Array, dstOffset);\n};\n\nexport const concatArrayBuffers2Uint8Array = (arrays: Array<ArrayBuffer>) => {\n  const uint8Arrays = arrays.map((arr) => new Uint8Array(arr));\n  return concatUint8Arrays(uint8Arrays);\n};\n\nexport const concatUint8Arrays = (arrays: Array<Uint8Array>) => {\n  let totalLength = 0;\n  for (const arr of arrays) {\n    totalLength += arr.byteLength;\n  }\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const arr of arrays) {\n    result.set(arr, offset);\n    offset += arr.byteLength;\n  }\n  return result;\n};\n","import { ByteData } from '../base/byte-data';\nimport { ErrorCode } from '../base/utils/error-map';\nimport { Log } from '../base/utils/log';\nimport { ByteArray } from './utils/byte-array';\nimport { memcpy } from './utils/byte-utils';\n\nexport const readByteDataWithStartCode = (byteArray: ByteArray) => {\n  const length = byteArray.readEncodedUint32();\n  const bytes = byteArray.readBytes(length);\n  if (length === 0) Log.error(ErrorCode.ReadStartCodeError);\n  const data = new ArrayBuffer(length + 4);\n  memcpy(data, 4, bytes.data(), 0, length);\n  const dataView = new DataView(data);\n  dataView.setUint8(0, 0);\n  dataView.setUint8(1, 0);\n  dataView.setUint8(2, 0);\n  dataView.setUint8(3, 1);\n  return new ByteData(new ByteArray(data), length + 4);\n};\n","import { VideoComposition } from '../../base/video-composition';\nimport { TagCode } from '../types';\nimport { ByteArray } from '../utils/byte-array';\nimport { readCompositionAttributes } from './composition-attributes';\nimport { readTags } from './tag-header';\nimport { readVideoSequence } from './video-sequence-tag';\n\nexport const readVideoComposition = (byteArray: ByteArray): VideoComposition => {\n  const composition = new VideoComposition();\n  composition.id = byteArray.readEncodedUint32();\n  composition.hasAlpha = byteArray.readBoolean();\n  const parameter = { composition, hasAlpha: composition.hasAlpha };\n  readTags(byteArray, parameter, ReadTagsOfVideoComposition);\n  return composition;\n};\n\nexport const ReadTagsOfVideoComposition = (\n  byteArray: ByteArray,\n  code: TagCode,\n  parameter: { composition: VideoComposition; hasAlpha: boolean },\n) => {\n  const { composition } = parameter;\n  switch (code) {\n    case TagCode.CompositionAttributes:\n      readCompositionAttributes(byteArray, composition);\n      break;\n    case TagCode.VideoSequence: {\n      const sequence = readVideoSequence(byteArray, parameter.hasAlpha);\n      sequence.composition = composition;\n      composition.sequences.push(sequence);\n      break;\n    }\n    default:\n      break;\n  }\n};\n","import { TimeRange } from '../../base/time-range';\nimport { VideoFrame } from '../../base/video-frame';\nimport { VideoSequence } from '../../base/video-sequence';\nimport { readTime } from '../data-types';\nimport { readByteDataWithStartCode } from '../nalu-start-code';\nimport { ByteArray } from '../utils/byte-array';\n\nexport const readVideoSequence = (byteArray: ByteArray, hasAlpha: boolean): VideoSequence => {\n  const videoSequence = new VideoSequence();\n  videoSequence.width = byteArray.readEncodeInt32();\n  videoSequence.height = byteArray.readEncodeInt32();\n  videoSequence.frameRate = byteArray.readFloat32();\n  if (hasAlpha) {\n    videoSequence.alphaStartX = byteArray.readEncodeInt32();\n    videoSequence.alphaStartY = byteArray.readEncodeInt32();\n  }\n\n  const sps = readByteDataWithStartCode(byteArray);\n  const pps = readByteDataWithStartCode(byteArray);\n  videoSequence.headers.push(sps, pps);\n\n  videoSequence.frameCount = byteArray.readEncodedUint32();\n  for (let i = 0; i < videoSequence.frameCount; i++) {\n    const videoFrame = new VideoFrame();\n    videoFrame.isKeyframe = byteArray.readBitBoolean();\n    videoSequence.frames.push(videoFrame);\n  }\n  for (let i = 0; i < videoSequence.frameCount; i++) {\n    const videoFrame = videoSequence.frames[i];\n    videoFrame.frame = readTime(byteArray);\n    videoFrame.fileBytes = readByteDataWithStartCode(byteArray);\n  }\n\n  if (byteArray.bytesAvailable > 0) {\n    const count = byteArray.readEncodedUint32();\n    for (let i = 0; i < count; i++) {\n      const staticTimeRange: TimeRange = { start: 0, end: 0 };\n      staticTimeRange.start = readTime(byteArray);\n      staticTimeRange.end = readTime(byteArray);\n      videoSequence.staticTimeRanges.push(staticTimeRange);\n    }\n  }\n\n  return videoSequence;\n};\n","import { Mask } from '../mask';\nimport { Property } from '../property';\nimport { TimeRange } from '../time-range';\n\nexport const enum EffectType {\n  Unknown,\n  Tint,\n  Fill,\n  Stroke,\n  Tritone,\n  DropShadow,\n  RadialWipe,\n  DisplacementMap,\n}\n\nexport class Effect {\n  public effectOpacity: Property<number> = undefined;\n  public maskReferences: Array<Mask>; // mask reference\n\n  public type(): EffectType {\n    return EffectType.Unknown;\n  }\n\n  public excludeVaryingRanges(_timeRanges: Array<TimeRange>): void {}\n\n  public gotoFrame(_time: number): void {}\n\n  public verify(): boolean {\n    return false;\n  }\n}\n","import { TagCode } from './types';\nimport { ByteArray } from './utils/byte-array';\nimport { Keyframe } from '../base/keyframe';\nimport { Property } from '../base/property';\nimport { BEZIER_PRECISION, readTime } from './data-types';\nimport { KeyframeInterpolationType } from '../constant';\nimport { AnimatableProperty } from '../base/animatable-property';\n\nexport const enum AttributeType {\n  Value,\n  FixedValue, // always exists, no need to store a flag.\n  SimpleProperty,\n  DiscreteProperty,\n  MultiDimensionProperty,\n  SpatialProperty,\n  BitFlag, // save bool value as a flag\n  Custom, // save a flag to indicate whether it should trigger a custom reading / writing action.\n}\n\nexport interface AttributeFlag {\n  /**\n   * Indicates whether or not this value is exist.\n   */\n  exist: boolean;\n  /**\n   * Indicates whether or not the size of this property's keyframes is greater than zero.\n   */\n  animatable: boolean;\n  /**\n   * Indicates whether or not this property has spatial values.\n   */\n  hasSpatial: boolean;\n}\n\nexport const readTagBlock = <T>(byteArray: ByteArray, parameter: T, blockConfig: BlockConfig) => {\n  const tagConfig: BlockConfig = blockConfig;\n  const flags: Array<AttributeFlag> = [];\n  if (!tagConfig.configs || tagConfig.configs.length === 0) {\n    return parameter;\n  }\n  for (const config of tagConfig.configs) {\n    const flag = readAttributeFlag(byteArray, config);\n    flags.push(flag);\n  }\n  byteArray.alignWithBytes();\n  let index = 0;\n  for (const config of tagConfig.configs) {\n    const flag = flags[index];\n    const target = config.key;\n    config.readAttribute(byteArray, flag, parameter as any as Object, target);\n    index += 1;\n  }\n  return parameter;\n};\n\nexport class BlockConfig {\n  public tagCode: TagCode = TagCode.End;\n  public configs: Array<BaseAttribute> = [];\n\n  public constructor(tagCode: TagCode) {\n    this.tagCode = tagCode;\n  }\n}\n\nexport class BaseAttribute {\n  public attributeType: AttributeType;\n  public defaultValue: any;\n  public key: string;\n\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    this.attributeType = attributeType;\n    this.defaultValue = defaultValue;\n    this.key = key;\n  }\n\n  public readAttribute(_byteArray: ByteArray, _flag: AttributeFlag, _targetClass: object, _target: string) {}\n\n  public readValue(_byteArray: ByteArray): any {\n    return undefined;\n  }\n\n  public readValueList(_byteArray: ByteArray, _list: Array<any>, _count: number) {}\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<any> {\n    return new Keyframe<any>();\n  }\n}\n\nexport const readAttribute = (\n  byteArray: ByteArray,\n  flag: AttributeFlag,\n  targetClass: object,\n  target: string,\n  config: BaseAttribute,\n) => {\n  if (config.attributeType === AttributeType.BitFlag) {\n    targetClass[target] = flag.exist;\n  } else if (config.attributeType === AttributeType.FixedValue) {\n    targetClass[target] = config.readValue(byteArray);\n  } else if (config.attributeType === AttributeType.Value) {\n    targetClass[target] = readValue(byteArray, config, flag);\n  } else {\n    targetClass[target] = readProperty(byteArray, config, flag);\n  }\n};\n\nexport const readProperty = <T>(byteArray: ByteArray, config: BaseAttribute, flag: AttributeFlag): any => {\n  let property: Property<T>;\n  if (flag.exist) {\n    if (flag.animatable) {\n      const keyframes: Array<Keyframe<T>> = readKeyframes(byteArray, config, flag);\n      if (!keyframes || keyframes.length === 0) {\n        throw 'Wrong number of keyframes.';\n        return property;\n      }\n      readTimeAndValue(byteArray, keyframes, config);\n      readTimeEase(byteArray, keyframes, config);\n      if (flag.hasSpatial) {\n        readSpatialEase(byteArray, keyframes);\n      }\n      property = new AnimatableProperty<T>(keyframes);\n    } else {\n      property = new Property<T>();\n      property.value = readValue(byteArray, config, flag);\n    }\n  } else {\n    property = new Property<T>();\n    property.value = config.defaultValue;\n  }\n  return property;\n};\n\nexport const readValue = (byteArray: ByteArray, config: BaseAttribute, flag: AttributeFlag): any => {\n  if (flag.exist) {\n    return config.readValue(byteArray);\n  }\n  return config.defaultValue;\n};\n\nexport const readAttributeFlag = (byteArray: ByteArray, config: BaseAttribute): AttributeFlag => {\n  const flag: AttributeFlag = { exist: false, animatable: false, hasSpatial: false };\n  const { attributeType } = config;\n  if (attributeType === AttributeType.FixedValue) {\n    flag.exist = true;\n    return flag;\n  }\n  flag.exist = byteArray.readBitBoolean();\n  if (\n    !flag.exist ||\n    attributeType === AttributeType.Value ||\n    attributeType === AttributeType.BitFlag ||\n    attributeType === AttributeType.Custom\n  ) {\n    return flag;\n  }\n  flag.animatable = byteArray.readBitBoolean();\n  if (!flag.animatable || attributeType !== AttributeType.SpatialProperty) {\n    return flag;\n  }\n  flag.hasSpatial = byteArray.readBitBoolean();\n  return flag;\n};\n\nexport const readKeyframes = <T>(\n  byteArray: ByteArray,\n  config: BaseAttribute,\n  flag: AttributeFlag,\n): Array<Keyframe<T>> => {\n  const keyframes: Array<any> = [];\n  const numFrames: number = byteArray.readEncodedUint32();\n  for (let i = 0; i < numFrames; i++) {\n    let keyframe: Keyframe<T>;\n    if (config.attributeType === AttributeType.DiscreteProperty) {\n      keyframe = new Keyframe<T>();\n    } else {\n      const interpolationType = byteArray.readUBits(2) as KeyframeInterpolationType;\n      if (interpolationType === KeyframeInterpolationType.Hold) {\n        keyframe = new Keyframe<T>();\n      } else {\n        keyframe = config.newKeyframe(flag);\n        keyframe.interpolationType = interpolationType;\n      }\n    }\n    keyframes.push(keyframe);\n  }\n\n  return keyframes;\n};\n\nconst readTimeAndValue = <T>(byteArray: ByteArray, keyframes: Array<Keyframe<T>>, config: BaseAttribute) => {\n  const numFrames: number = keyframes.length;\n  keyframes[0].startTime = readTime(byteArray);\n  for (let i = 0; i < numFrames; i++) {\n    const time: number = readTime(byteArray);\n    keyframes[i].endTime = time;\n    if (i < numFrames - 1) {\n      keyframes[i + 1].startTime = time;\n    }\n  }\n  const list: Array<T> = [];\n  config.readValueList(byteArray, list, numFrames + 1);\n  let index = 0;\n  keyframes[0].startValue = list[index];\n  index += 1;\n  for (let i = 0; i < numFrames; i++) {\n    const value = list[index];\n    index += 1;\n    keyframes[i].endValue = value;\n    if (i < numFrames - 1) {\n      keyframes[i + 1].startValue = value;\n    }\n  }\n};\n\nconst readTimeEase = <T>(byteArray: ByteArray, keyframes: Array<Keyframe<T>>, config: BaseAttribute) => {\n  const dimensionality: number =\n    config.attributeType === AttributeType.MultiDimensionProperty ? config.dimensionality() : 1;\n  const numBits: number = byteArray.readNumBits();\n  for (const keyframe of keyframes) {\n    if (keyframe.interpolationType !== KeyframeInterpolationType.Bezier) {\n      continue;\n    }\n    let x: number;\n    let y: number;\n    for (let i = 0; i < dimensionality; i++) {\n      x = byteArray.readBits(numBits) * BEZIER_PRECISION;\n      y = byteArray.readBits(numBits) * BEZIER_PRECISION;\n      keyframe.bezierOut.push({ x, y });\n      x = byteArray.readBits(numBits) * BEZIER_PRECISION;\n      y = byteArray.readBits(numBits) * BEZIER_PRECISION;\n      keyframe.bezierIn.push({ x, y });\n    }\n  }\n};\n\nconst readSpatialEase = <T>(_byteArray: ByteArray, _keyframes: Array<Keyframe<T>>) => {};\n","export interface TimeRange {\n  start: number;\n  end: number;\n}\n\nexport function subtractFromTimeRanges(timeRanges: Array<TimeRange>, startTime: number, endTime: number) {\n  if (endTime < startTime) {\n    return;\n  }\n  const size = timeRanges.length;\n  for (let i = size - 1; i >= 0; i--) {\n    const timeRange = timeRanges[i];\n    if (timeRange.end < startTime || timeRange.start > endTime) {\n      continue;\n    }\n    if (timeRange.start < startTime && timeRange.end > endTime) {\n      const range = { start: endTime + 1, end: timeRange.end };\n      timeRange.end = startTime - 1;\n      if (range.end > range.start) {\n        timeRanges.splice(i + 1, 0, range);\n      }\n      if (timeRange.end <= timeRange.start) {\n        timeRanges.splice(i, 1);\n      }\n      break;\n    }\n    if (timeRange.start >= startTime && timeRange.end <= endTime) {\n      timeRanges.splice(i, 1);\n    } else if (timeRange.start < startTime) {\n      timeRange.end = startTime - 1;\n      if (timeRange.end <= timeRange.start) {\n        timeRanges.splice(i, 1);\n      }\n    } else {\n      timeRange.start = endTime + 1;\n      if (timeRange.end <= timeRange.start) {\n        timeRanges.splice(i, 1);\n      }\n    }\n  }\n}\n\nexport function splitTimeRangesAt(timeRanges: Array<TimeRange>, startTime: number) {\n  const size = timeRanges.length;\n  for (let i = size - 1; i >= 0; i--) {\n    const timeRange = timeRanges[i];\n    if (timeRange.start === startTime || timeRange.end <= startTime) {\n      break;\n    }\n    if (timeRange.start < startTime && timeRange.end > startTime) {\n      const range = { start: startTime, end: timeRange.end };\n      timeRange.end = startTime - 1;\n      if (range.end > range.start) {\n        timeRanges.splice(i + 1, 0, range);\n      }\n      if (timeRange.end <= timeRange.start) {\n        timeRanges.splice(i, 1);\n      }\n      break;\n    }\n  }\n}\n\nfunction findTimeRangeAt(timeRanges: Array<TimeRange>, position: number, start: number, end: number): number {\n  if (start > end) {\n    return -1;\n  }\n  const index = Math.ceil((start + end) * 0.5);\n  const timeRange = timeRanges[index];\n  if (timeRange.start > position) {\n    return findTimeRangeAt(timeRanges, position, start, index - 1);\n  }\n  if (timeRange.end < position) {\n    return findTimeRangeAt(timeRanges, position, index + 1, end);\n  }\n  return index;\n}\n\nexport function convertFrameByStaticTimeRanges(timeRanges: Array<TimeRange>, frame: number): number {\n  const index = findTimeRangeAt(timeRanges, frame, 0, timeRanges.length - 1);\n  return index !== -1 ? timeRanges[index].start : frame;\n}\n","import { CompositionType } from '../codec/types';\nimport { Composition } from './composition';\nimport { Layer } from './layer';\nimport { splitTimeRangesAt, TimeRange } from './time-range';\nimport { verifyFailed } from './utils/verify';\n\nexport class VectorComposition extends Composition {\n  public layers: Array<Layer> = [];\n\n  private staticTimeRanges: Array<TimeRange> = [];\n  private staticTimeRangeUpdated = false;\n\n  public type(): CompositionType {\n    return CompositionType.Vector;\n  }\n\n  /**\n   * Returns the static time ranges of this composition.\n   */\n  public getStaticTimeRanges(): Array<TimeRange> {\n    if (!this.staticTimeRangeUpdated) {\n      this.staticTimeRangeUpdated = true;\n      this.updateStaticTimeRanges();\n    }\n    return this.staticTimeRanges;\n  }\n\n  public verify(): boolean {\n    if (!super.verify()) {\n      verifyFailed();\n      return false;\n    }\n    for (const layer of this.layers) {\n      if (!layer || !layer.verify()) {\n        verifyFailed();\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private updateStaticTimeRanges() {\n    if (this.duration > 1) {\n      const range = { start: 0, end: this.duration - 1 };\n      this.staticTimeRanges = [range];\n      for (const layer of this.layers) {\n        if (this.staticTimeRanges.length <= 0) {\n          break;\n        }\n        layer.excludeVaryingRanges(this.staticTimeRanges);\n        splitTimeRangesAt(this.staticTimeRanges, layer.startTime);\n        splitTimeRangesAt(this.staticTimeRanges, layer.startTime + layer.duration);\n      }\n    }\n  }\n}\n","import { TimeRange } from './time-range';\n\nexport class Property<T> {\n  public value: T;\n\n  public animatable(): boolean {\n    return false;\n  }\n\n  public excludeVaryingRanges(_timeRanges: Array<TimeRange>): void {}\n\n  public gotoFrame(_time: number): void {}\n}\n","import { Point, ZERO_POINT } from './point';\nimport { Property } from './property';\nimport { TimeRange } from './time-range';\n\nexport class Transform2D {\n  public static createDefaultTransform2D() {\n    const transform = new Transform2D();\n    transform.anchorPoint = new Property<Point>();\n    transform.anchorPoint.value = ZERO_POINT;\n    transform.position = new Property<Point>();\n    transform.position.value = ZERO_POINT;\n    transform.xPosition = new Property<number>();\n    transform.xPosition.value = 0;\n    transform.yPosition = new Property<number>();\n    transform.yPosition.value = 0;\n    transform.scale = new Property<Point>();\n    transform.scale.value = new Point(1, 1);\n    transform.rotation = new Property<number>();\n    transform.rotation.value = 0;\n    transform.opacity = new Property<number>();\n    transform.opacity.value = 255;\n    return transform;\n  }\n\n  public anchorPoint: Property<Point> = undefined; // spatial\n  public position: Property<Point> = undefined; // spatial\n  public xPosition: Property<number> = undefined;\n  public yPosition: Property<number> = undefined;\n  public scale: Property<Point> = undefined; // multidimensional\n  public rotation: Property<number> = undefined;\n  public opacity: Property<number> = undefined;\n\n  public excludeVaryingRanges(timeRanges: Array<TimeRange>): void {\n    this.anchorPoint.excludeVaryingRanges(timeRanges);\n    if (this.position !== undefined) {\n      this.position.excludeVaryingRanges(timeRanges);\n    } else {\n      this.xPosition.excludeVaryingRanges(timeRanges);\n      this.yPosition.excludeVaryingRanges(timeRanges);\n    }\n    this.scale.excludeVaryingRanges(timeRanges);\n    this.rotation.excludeVaryingRanges(timeRanges);\n    this.opacity.excludeVaryingRanges(timeRanges);\n  }\n\n  public gotoFrame(frame: number): void {\n    this.anchorPoint.gotoFrame(frame);\n    if (this.position !== undefined) {\n      this.position.gotoFrame(frame);\n    } else {\n      this.xPosition.gotoFrame(frame);\n      this.yPosition.gotoFrame(frame);\n    }\n    this.scale.gotoFrame(frame);\n    this.rotation.gotoFrame(frame);\n    this.opacity.gotoFrame(frame);\n  }\n\n  public verify(): boolean {\n    return (\n      this.anchorPoint !== undefined &&\n      (this.position !== undefined || (this.xPosition !== undefined && this.yPosition !== undefined)) &&\n      this.scale !== undefined &&\n      this.rotation !== undefined &&\n      this.opacity !== undefined\n    );\n  }\n}\n","import { OPAQUE, ZERO_TIME } from '../constant';\nimport { Composition } from './composition';\nimport { Layer, LayerType } from './layer';\nimport { Point, ZERO_POINT } from './point';\nimport { Property } from './property';\nimport { TimeRange } from './time-range';\nimport { Transform2D } from './transform-2d';\nimport { Opacity } from './types';\n\nexport class PreComposeLayer extends Layer {\n  public static wrap(composition: Composition) {\n    const layer = new PreComposeLayer();\n    layer.duration = composition.duration;\n    const transform = new Transform2D();\n    transform.anchorPoint = new Property<Point>();\n    transform.anchorPoint.value = ZERO_POINT;\n    transform.position = new Property<Point>();\n    transform.position.value = ZERO_POINT;\n    transform.scale = new Property<Point>();\n    transform.scale.value = new Point(1, 1);\n    transform.rotation = new Property<number>();\n    transform.rotation.value = 0;\n    transform.opacity = new Property<Opacity>();\n    transform.opacity.value = OPAQUE;\n    layer.transform = transform;\n    layer.composition = composition;\n    return layer;\n  }\n\n  /**\n   * composition reference\n   */\n  public composition: Composition = undefined;\n\n  /**\n   * Indicates when the first frame of the composition shows in the layer's timeline. It could be a negative value.\n   */\n  public compositionStartTime: number = ZERO_TIME;\n\n  private staticTimeRanges: Array<TimeRange> = undefined;\n  private staticTimeRangeUpdated = false;\n\n  public type(): LayerType {\n    return LayerType.PreCompose;\n  }\n\n  public excludeVaryingRanges(timeRanges: Array<TimeRange>): void {\n    super.excludeVaryingRanges(timeRanges);\n    if (!timeRanges || timeRanges.length === 0) {\n      return;\n    }\n    this.updateStaticTimeRanges();\n  }\n\n  public gotoFrame(frame: number): void {\n    super.gotoFrame(frame);\n  }\n\n  public verify(): boolean {\n    if (!super.verify()) {\n      return false;\n    }\n    if (this.composition) {\n      return true;\n    }\n    return false;\n  }\n\n  private updateStaticTimeRanges(): void {\n    if (this.staticTimeRangeUpdated) {\n      return;\n    }\n    this.staticTimeRangeUpdated = true;\n    const ranges: Array<TimeRange> = this.composition.getStaticTimeRanges();\n    for (let i = ranges.length - 1; i >= 0; i--) {\n      const range: TimeRange = ranges[i];\n      range.start += this.compositionStartTime;\n      range.end += this.compositionStartTime;\n      if (range.end <= this.startTime) {\n        ranges.pop();\n      } else if (range.start < this.startTime) {\n        range.start = 0;\n      } else if (range.start >= this.startTime + this.duration - 1) {\n        ranges.pop();\n      } else if (range.end > this.startTime + this.duration - 1) {\n        range.end = this.startTime + this.duration - 1;\n      }\n    }\n    this.staticTimeRanges = ranges;\n  }\n}\n","import { Layer, LayerType } from './layer';\nimport { ShapeElement } from './shape-element';\nimport { TimeRange } from './time-range';\n\nexport class ShapeLayer extends Layer {\n  private contents: Array<ShapeElement> = [];\n\n  public type(): LayerType {\n    return LayerType.Shape;\n  }\n\n  public excludeVaryingRanges(timeRanges: Array<TimeRange>) {\n    super.excludeVaryingRanges(timeRanges);\n    for (const element of this.contents) {\n      element.excludeVaryingRanges(timeRanges);\n    }\n  }\n\n  public gotoFrame(frame: number) {\n    super.gotoFrame(frame);\n    for (const element of this.contents) {\n      element.gotoFrame(frame);\n    }\n  }\n\n  public verify(): boolean {\n    if (!super.verify()) {\n      return false;\n    }\n\n    for (const element of this.contents) {\n      if (element === undefined || !element.verify()) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","import { Black, Color } from './color';\nimport { Layer, LayerType } from './layer';\nimport { TimeRange } from './time-range';\nimport { verifyAndrReturn, verifyFailed } from './utils/verify';\n\nexport class SolidLayer extends Layer {\n  public solidColor: Color = Black;\n  public width = 0;\n  public height = 0;\n\n  public type(): LayerType {\n    return LayerType.Solid;\n  }\n\n  public excludeVaryingRanges(timeRanges: Array<TimeRange>) {\n    super.excludeVaryingRanges(timeRanges);\n  }\n\n  public gotoFrame(frame: number) {\n    super.gotoFrame(frame);\n  }\n\n  public verify(): boolean {\n    if (!super.verify()) {\n      verifyFailed();\n      return false;\n    }\n    return verifyAndrReturn(this.width > 0 && this.height > 0);\n  }\n}\n","import { Layer, LayerType } from './layer';\n\nexport class UnDefinedLayer extends Layer {\n  public type(): LayerType {\n    return LayerType.undefined;\n  }\n}\n","import { KeyframeInterpolationType } from '../constant';\nimport { Point, ZERO_POINT } from './point';\n\nexport class Keyframe<T> {\n  public startValue: T;\n  public endValue: T;\n  public startTime = 0;\n  public endTime = 0;\n  public interpolationType: KeyframeInterpolationType = KeyframeInterpolationType.Hold; // 插补类型\n  public bezierOut: Array<Point> = [];\n  public bezierIn: Array<Point> = [];\n  public spatialOut: Point = ZERO_POINT;\n  public spatialIn: Point = ZERO_POINT;\n\n  public initialize(): void {}\n\n  public getValue(_time: number): any {\n    return this.startValue;\n  }\n\n  public containsTime(time: number): boolean {\n    return time >= this.startTime && time < this.endTime;\n  }\n}\n","import { KeyframeInterpolationType } from '../constant';\nimport { Keyframe } from './keyframe';\nimport { Property } from './property';\nimport { splitTimeRangesAt, subtractFromTimeRanges, TimeRange } from './time-range';\n\nexport class AnimatableProperty<T> extends Property<T> {\n  private lastKeyframeIndex = 0;\n\n  public constructor(public keyframes: Array<Keyframe<T>>) {\n    super();\n    if (keyframes !== undefined && keyframes.length > 0) {\n      this.value = keyframes[0].startValue;\n    }\n    for (const keyframe of keyframes) {\n      keyframe.initialize();\n    }\n  }\n\n  public animatable(): boolean {\n    return true;\n  }\n\n  public excludeVaryingRanges(timeRanges: Array<TimeRange>): void {\n    for (const keyframe of this.keyframes) {\n      switch (keyframe.interpolationType) {\n        case KeyframeInterpolationType.Bezier:\n        case KeyframeInterpolationType.Linear:\n          subtractFromTimeRanges(timeRanges, keyframe.startTime, keyframe.endTime - 1);\n          break;\n        default:\n          splitTimeRangesAt(timeRanges, keyframe.startTime);\n          splitTimeRangesAt(timeRanges, keyframe.endTime);\n          break;\n      }\n    }\n  }\n\n  public gotoFrame(frame: number): void {\n    let lastKeyframe = this.keyframes[this.lastKeyframeIndex];\n    if (lastKeyframe.containsTime(frame)) {\n      this.value = lastKeyframe.getValue(frame);\n      return;\n    }\n    if (frame < lastKeyframe.startTime) {\n      while (this.lastKeyframeIndex > 0) {\n        this.lastKeyframeIndex -= 1;\n        if (this.keyframes[this.lastKeyframeIndex].containsTime(frame)) {\n          break;\n        }\n      }\n    } else {\n      while (this.lastKeyframeIndex < this.keyframes.length - 1) {\n        this.lastKeyframeIndex += 1;\n        if (this.keyframes[this.lastKeyframeIndex].containsTime(frame)) {\n          break;\n        }\n      }\n    }\n    lastKeyframe = this.keyframes[this.lastKeyframeIndex];\n    if (frame <= lastKeyframe.startTime) {\n      this.value = lastKeyframe.startValue;\n    } else if (frame >= lastKeyframe.endTime) {\n      this.value = lastKeyframe.endValue;\n    } else {\n      this.value = lastKeyframe.getValue(frame);\n    }\n  }\n}\n","export function interpolateFloat(a: number, b: number, t: number): number {\n  return a + (b - a) * t;\n}\n","export class Interpolator {\n  public getInterpolation(input: number): number {\n    return input;\n  }\n}\n","import { KeyframeInterpolationType } from '../../constant';\nimport { Keyframe } from '../keyframe';\nimport { Point } from '../point';\nimport { interpolateFloat } from '../utils/interpolate';\nimport { Interpolator } from '../utils/interpolator';\n\nexport class MultiDimensionPointKeyframe extends Keyframe<Point> {\n  private xInterpolator: Interpolator = undefined;\n  private yInterpolator: Interpolator = undefined;\n\n  public initialize(): void {\n    super.initialize();\n    if (this.interpolationType === KeyframeInterpolationType.Bezier) {\n      // todo sun bezier\n      // this.xInterpolator = new BezierEasing(this.bezierOut[0], this.bezierIn[0]);\n      // this.yInterpolator = new BezierEasing(this.bezierOut[1], this.bezierIn[1]);\n    } else {\n      this.xInterpolator = new Interpolator();\n      this.yInterpolator = new Interpolator();\n    }\n  }\n\n  public getValue(time: number): Point {\n    const progress = (time - this.startTime) / (this.endTime - this.startTime);\n    const xProgress = this.xInterpolator.getInterpolation(progress);\n    const yProgress = this.yInterpolator.getInterpolation(progress);\n    const x = interpolateFloat(this.startValue.x, this.endValue.x, xProgress);\n    const y = interpolateFloat(this.startValue.y, this.endValue.y, yProgress);\n    return { x, y };\n  }\n}\n","import { KeyframeInterpolationType } from '../../constant';\nimport { Keyframe } from '../keyframe';\nimport { interpolateFloat } from '../utils/interpolate';\nimport { Interpolator } from '../utils/interpolator';\n\nexport class SingleEaseKeyframe<T> extends Keyframe<T> {\n  private interpolator: Interpolator = undefined;\n\n  public initialize() {\n    if (this.interpolationType === KeyframeInterpolationType.Bezier) {\n      // Bazier相关\n    } else {\n      this.interpolator = new Interpolator();\n    }\n  }\n\n  public getProgress(time: number): number {\n    const progress = (time - this.startTime) / (this.endTime - this.startTime);\n    return this.interpolator.getInterpolation(progress);\n  }\n\n  public getValue(time: number): number {\n    const progress = this.getProgress(time);\n    return interpolateFloat(this.startValue as any as number, this.endValue as any as number, progress);\n  }\n}\n","import { Color } from '../base/color';\nimport { Composition } from '../base/composition';\nimport { Keyframe } from '../base/keyframe';\nimport { MultiDimensionPointKeyframe } from '../base/keyframes/multi-dimension-point-keyframe';\nimport { SingleEaseKeyframe } from '../base/keyframes/single-ease-keyframe';\nimport { Layer } from '../base/layer';\nimport { Point } from '../base/point';\nimport { Ratio } from '../base/ratio';\nimport { AttributeFlag, AttributeType, BaseAttribute, readAttribute } from './attribute-helper';\nimport {\n  readColor,\n  readCompositionID,\n  readLayerID,\n  readPoint,\n  readRatio,\n  readTime,\n  SPATIAL_PRECISION,\n} from './data-types';\nimport { ByteArray } from './utils/byte-array';\n\nexport interface BaseAttributeConfig<T> {\n  newKeyframe(flag: AttributeFlag): Keyframe<T>;\n}\n\nexport class FloatAttributeConfig extends BaseAttribute implements BaseAttributeConfig<number> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): number {\n    return byteArray.readFloat32();\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<number>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list.push(this.readValue(byteArray));\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<number> {\n    return new SingleEaseKeyframe<number>();\n  }\n}\n\nexport class BOOLAttributeConfig extends BaseAttribute implements BaseAttributeConfig<Boolean> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): boolean {\n    return byteArray.readBoolean();\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<boolean>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list.push(byteArray.readBitBoolean());\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<boolean> {\n    return new Keyframe<boolean>();\n  }\n}\n\nexport class Uint8AttributeConfig extends BaseAttribute implements BaseAttributeConfig<number> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: number) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): number {\n    return byteArray.readUint8();\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<number>, count: number) {\n    const valueList = byteArray.readUint32List(count);\n    for (let i = 0; i < count; i++) {\n      list.push(valueList[i]);\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<number> {\n    return new SingleEaseKeyframe<number>();\n  }\n}\n\nexport class AttributeConfigUint32 extends BaseAttribute implements BaseAttributeConfig<number> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): number {\n    return byteArray.readEncodedUint32();\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<number>, count: number) {\n    list = byteArray.readUint32List(count);\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<number> {\n    return new SingleEaseKeyframe<number>();\n  }\n}\n\nexport class TimeAttributeConfig extends BaseAttribute implements BaseAttributeConfig<number> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): number {\n    return readTime(byteArray);\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<number>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list[i] = this.readValue(byteArray);\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<number> {\n    return new SingleEaseKeyframe<number>();\n  }\n}\n\nexport class PointAttributeConfig extends BaseAttribute implements BaseAttributeConfig<Point> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): Point {\n    return readPoint(byteArray);\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<Point>, count: number) {\n    if (this.attributeType === AttributeType.SpatialProperty) {\n      const values: number[] = byteArray.readFloatList(count * 2, SPATIAL_PRECISION);\n      for (let i = 0; i < count; i++) {\n        list[i] || (list[i] = new Point(0, 0));\n        list[i].x = values[i];\n      }\n    } else {\n      for (let i = 0; i < count; i++) {\n        list[i] = readPoint(byteArray);\n      }\n    }\n  }\n\n  public dimensionality(): number {\n    return 2;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<Point> {\n    switch (this.attributeType) {\n      case AttributeType.MultiDimensionProperty:\n        return new MultiDimensionPointKeyframe();\n      default:\n        return new SingleEaseKeyframe<Point>();\n    }\n  }\n}\n\nexport class ColorAttributeConfig extends BaseAttribute implements BaseAttributeConfig<Color> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): Color {\n    return readColor(byteArray);\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<Color>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list[i] = this.readValue(byteArray);\n    }\n  }\n\n  public dimensionality(): number {\n    return 3;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<Color> {\n    return new SingleEaseKeyframe<Color>();\n  }\n}\n\nexport class RatioAttributeConfig extends BaseAttribute implements BaseAttributeConfig<Ratio> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): Ratio {\n    return readRatio(byteArray);\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<Ratio>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list[i] = this.readValue(byteArray);\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<Ratio> {\n    return new SingleEaseKeyframe<Ratio>();\n  }\n}\n\nexport class StringAttributeConfig extends BaseAttribute implements BaseAttributeConfig<string> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): string {\n    return byteArray.readUTF8String();\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<string>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list[i] = this.readValue(byteArray);\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<string> {\n    return new SingleEaseKeyframe<string>();\n  }\n}\n\nexport class LayerAttributeConfig extends BaseAttribute implements BaseAttributeConfig<Layer> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): Layer {\n    return readLayerID(byteArray);\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<Layer>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list[i] = this.readValue(byteArray);\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<Layer> {\n    return new SingleEaseKeyframe<Layer>();\n  }\n}\n\nexport class CompositionAttributeConfig extends BaseAttribute implements BaseAttributeConfig<Composition> {\n  public constructor(key: string, attributeType: AttributeType, defaultValue: any) {\n    super(key, attributeType, defaultValue);\n  }\n\n  public readAttribute(byteArray: ByteArray, flag: AttributeFlag, targetClass: object, target: string) {\n    readAttribute(byteArray, flag, targetClass, target, this);\n  }\n\n  public readValue(byteArray: ByteArray): Composition {\n    return readCompositionID(byteArray);\n  }\n\n  public readValueList(byteArray: ByteArray, list: Array<Composition>, count: number) {\n    for (let i = 0; i < count; i++) {\n      list[i] = this.readValue(byteArray);\n    }\n  }\n\n  public dimensionality(): number {\n    return 1;\n  }\n\n  public newKeyframe(_flag: AttributeFlag): Keyframe<Composition> {\n    return new SingleEaseKeyframe<Composition>();\n  }\n}\n","import { TrackMatteType } from '../../base/layer';\nimport { Point, ZERO_POINT } from '../../base/point';\nimport { DefaultRatio } from '../../base/ratio';\nimport { BlendMode, OPAQUE, ZERO_TIME } from '../../constant';\nimport { TagCode } from '../types';\nimport { AttributeType, BlockConfig } from '../attribute-helper';\nimport {\n  BOOLAttributeConfig,\n  FloatAttributeConfig,\n  LayerAttributeConfig,\n  PointAttributeConfig,\n  RatioAttributeConfig,\n  StringAttributeConfig,\n  TimeAttributeConfig,\n  Uint8AttributeConfig,\n} from '../attributes';\n\nexport const readBlockConfigOfLayerAttributes: BlockConfig = {\n  tagCode: TagCode.LayerAttributes,\n  configs: [\n    new BOOLAttributeConfig('isActive', AttributeType.BitFlag, true),\n    new BOOLAttributeConfig('autoOrientation', AttributeType.BitFlag, false),\n    new LayerAttributeConfig('parent', AttributeType.Value, undefined),\n    new RatioAttributeConfig('stretch', AttributeType.Value, DefaultRatio),\n    new TimeAttributeConfig('startTime', AttributeType.Value, ZERO_TIME),\n    new Uint8AttributeConfig('blendMode', AttributeType.Value, BlendMode.Normal),\n    new Uint8AttributeConfig('trackMatteType', AttributeType.Value, TrackMatteType.None),\n    new FloatAttributeConfig('timeRemap', AttributeType.SimpleProperty, 0),\n    new TimeAttributeConfig('duration', AttributeType.FixedValue, ZERO_TIME),\n  ],\n};\n\nexport const readBlockConfigOfLayerAttributesV2: BlockConfig = {\n  tagCode: TagCode.LayerAttributesV2,\n  configs: [\n    new BOOLAttributeConfig('isActive', AttributeType.BitFlag, true),\n    new BOOLAttributeConfig('autoOrientation', AttributeType.BitFlag, false),\n    new LayerAttributeConfig('parent', AttributeType.Value, undefined),\n    new RatioAttributeConfig('stretch', AttributeType.Value, DefaultRatio),\n    new TimeAttributeConfig('startTime', AttributeType.Value, ZERO_TIME),\n    new Uint8AttributeConfig('blendMode', AttributeType.Value, BlendMode.Normal),\n    new Uint8AttributeConfig('trackMatteType', AttributeType.Value, TrackMatteType.None),\n    new FloatAttributeConfig('timeRemap', AttributeType.SimpleProperty, 0),\n    new TimeAttributeConfig('duration', AttributeType.FixedValue, ZERO_TIME),\n    new StringAttributeConfig('name', AttributeType.Value, ''),\n  ],\n};\n\nexport const readBlockConfigOfTransform2D: BlockConfig = {\n  tagCode: TagCode.Transform2D,\n  configs: [\n    new PointAttributeConfig('anchorPoint', AttributeType.SpatialProperty, ZERO_POINT),\n    new PointAttributeConfig('position', AttributeType.SpatialProperty, ZERO_POINT),\n    new FloatAttributeConfig('xPosition', AttributeType.SimpleProperty, 0),\n    new FloatAttributeConfig('yPosition', AttributeType.SimpleProperty, 0),\n    new PointAttributeConfig('scale', AttributeType.MultiDimensionProperty, new Point(1, 1)),\n    new FloatAttributeConfig('rotation', AttributeType.SimpleProperty, 0),\n    new Uint8AttributeConfig('opacity', AttributeType.SimpleProperty, OPAQUE),\n  ],\n};\n\nexport const readBlockConfigOfMask: BlockConfig = {\n  tagCode: TagCode.MaskBlock,\n  configs: [],\n};\n","import { Layer, LayerType } from '../../base/layer';\nimport { ZERO_POINT } from '../../base/point';\nimport { PreComposeLayer } from '../../base/pre-compose-layer';\nimport { ShapeLayer } from '../../base/shape-layer';\nimport { SolidLayer } from '../../base/solid-layer';\nimport { Transform2D } from '../../base/transform-2d';\nimport { UnDefinedLayer } from '../../base/un-defined-layer';\nimport { TagCode } from '../types';\nimport { readTagBlock } from '../attribute-helper';\nimport { ByteArray } from '../utils/byte-array';\nimport { readSolidColor } from './solid-layer';\nimport {\n  readBlockConfigOfLayerAttributes,\n  readBlockConfigOfLayerAttributesV2,\n  readBlockConfigOfTransform2D,\n} from './tag-attributes';\nimport { readTags } from './tag-header';\nimport { readCompositionReference } from './read-composition-reference';\n\nexport const readLayer = (byteArray: ByteArray): Layer => {\n  const layerType: LayerType = byteArray.readUint8();\n  let layer: Layer;\n  switch (layerType) {\n    case LayerType.undefined:\n      layer = new UnDefinedLayer();\n      break;\n    case LayerType.Solid:\n      layer = new SolidLayer();\n      break;\n    case LayerType.Shape:\n      layer = new ShapeLayer();\n      break;\n    case LayerType.PreCompose:\n      layer = new PreComposeLayer();\n      break;\n    default:\n      layer = new Layer();\n      break;\n  }\n  layer.id = byteArray.readEncodedUint32();\n  readTags(byteArray, layer, readTagsOfLayer);\n  return layer;\n};\n\nexport const readTagsOfLayer = (byteArray: ByteArray, code: TagCode, layer: Layer) => {\n  switch (code) {\n    case TagCode.LayerAttributes:\n      readTagBlock(byteArray, layer, readBlockConfigOfLayerAttributes);\n      if (layer.duration <= 0) layer.duration = 1;\n      break;\n    case TagCode.LayerAttributesV2:\n      readTagBlock(byteArray, layer, readBlockConfigOfLayerAttributesV2);\n      if (layer.duration <= 0) layer.duration = 1;\n      break;\n    case TagCode.Transform2D:\n      layer.transform = new Transform2D();\n      readTagBlock(byteArray, layer.transform, readBlockConfigOfTransform2D);\n      // hasPosition || (!hasXPosition && !hasXPosition)\n      if (\n        layer.transform.position.animatable() ||\n        layer.transform.position.value !== ZERO_POINT ||\n        (!(layer.transform.xPosition.animatable() || layer.transform.xPosition.value !== 0) &&\n          !(layer.transform.yPosition.animatable() || layer.transform.yPosition.value !== 0))\n      ) {\n        layer.transform.xPosition = undefined;\n        layer.transform.yPosition = undefined;\n      } else {\n        layer.transform.position = undefined;\n      }\n      break;\n    case TagCode.SolidColor:\n      if (layer.type() === LayerType.Solid) {\n        readSolidColor(byteArray, layer as SolidLayer);\n      }\n      break;\n    case TagCode.CompositionReference:\n      if (layer.type() === LayerType.PreCompose) {\n        readCompositionReference(byteArray, layer as PreComposeLayer);\n      }\n      break;\n    default:\n      break;\n  }\n};\n","import { SolidLayer } from '../../base/solid-layer';\nimport { readColor } from '../data-types';\nimport { ByteArray } from '../utils/byte-array';\n\nexport function readSolidColor(byteArray: ByteArray, layer: SolidLayer) {\n  layer.solidColor = readColor(byteArray);\n  layer.width = byteArray.readEncodeInt32();\n  layer.height = byteArray.readEncodeInt32();\n}\n","import { ByteArray } from '../utils/byte-array';\nimport { PreComposeLayer } from '../../base/pre-compose-layer';\nimport { Composition } from '../../base/composition';\nimport { readTime } from '../data-types';\n\nexport function readCompositionReference(byteArray: ByteArray, layer: PreComposeLayer) {\n  const id = byteArray.readEncodedUint32();\n  if (id > 0) {\n    layer.composition = new Composition();\n    layer.composition.id = id;\n  }\n  layer.compositionStartTime = readTime(byteArray);\n}\n","import { EffectType } from '../../base/effects/effect';\nimport { FillEffect } from '../../base/effects/fill-effect';\nimport { StrokeEffect } from '../../base/effects/stroke-effect';\nimport { Layer, LayerType, TrackMatteType } from '../../base/layer';\nimport { Mask } from '../../base/mask';\nimport { TextLayer } from '../../base/text-layer';\nimport { VectorComposition } from '../../base/vector-composition';\nimport { TagCode } from '../types';\nimport { ByteArray } from '../utils/byte-array';\nimport { readCompositionAttributes } from './composition-attributes';\nimport { readLayer } from './layer-tag';\nimport { readTags } from './tag-header';\n\nexport const readVectorComposition = (byteArray: ByteArray): VectorComposition => {\n  const composition = new VectorComposition();\n  composition.id = byteArray.readEncodedUint32();\n  readTags(byteArray, composition, readTagsOfVectorComposition);\n  installArrayLayerReference(composition.layers);\n  return composition;\n};\n\nexport const readTagsOfVectorComposition = (byteArray: ByteArray, code: TagCode, composition: VectorComposition) => {\n  switch (code) {\n    case TagCode.CompositionAttributes:\n      readCompositionAttributes(byteArray, composition);\n      break;\n    case TagCode.LayerBlock:\n      composition.layers.push(readLayer(byteArray));\n      break;\n    default:\n      break;\n  }\n};\n\nexport const installArrayLayerReference = (layers: Array<Layer>) => {\n  if (!layers || layers.length === 0) {\n    return;\n  }\n  const layerMap = new Map();\n  for (const layer of layers) {\n    if (!layer) {\n      continue;\n    }\n    installLayerReference(layer);\n    layerMap.set(layer.id, layer);\n  }\n\n  let index = 0;\n  for (const layer of layers) {\n    if (!layer) {\n      continue;\n    }\n    if (layer.parent !== undefined) {\n      const ID = layer.parent.id;\n      const result = layerMap.get(ID);\n      if (result !== undefined) {\n        layer.parent = result;\n      }\n    }\n    if (index > 0 && hasTrackMatte(layer.trackMatteType)) {\n      layer.trackMatteLayer = layers[index - 1];\n    }\n    if (layer.effects !== undefined && layer.effects.length > 0) {\n      for (const effect of layer.effects) {\n        if (!effect) {\n          continue;\n        }\n        if (effect.type() === EffectType.DisplacementMap) {\n          // let displacementMapEffect = <DisplacementMapEffect> effect;\n          // if (displacementMapEffect.displacementMapLayer != undefined) {\n          //     let ID = displacementMapEffect.displacementMapLayer.id;\n          //     let result = layerMap.get(ID);\n          //     if (result != undefined) {\n          //         displacementMapEffect.displacementMapLayer = result;\n          //     }\n          // }\n        }\n      }\n    }\n    index += 1;\n  }\n};\n\n/**\n * 将Layer里面的MaskID标识换成真正的Mask\n * @param layer\n */\nexport const installLayerReference = (layer: Layer) => {\n  if (!layer || !layer.masks || layer.masks.length === 0) {\n    return;\n  }\n  const maskMap = new Map();\n  for (const mask of layer.masks) {\n    if (!mask) {\n      continue;\n    }\n    maskMap.set(mask.id, mask);\n  }\n  if (layer.effects !== undefined && layer.effects.length > 0) {\n    for (const effect of layer.effects) {\n      if (!effect) {\n        continue;\n      }\n      if (effect.maskReferences !== undefined && effect.maskReferences.length > 0) {\n        const maskReferences = new Array<Mask>();\n        for (const mask of effect.maskReferences) {\n          const ID = mask.id;\n          const result = maskMap.get(ID);\n          if (result !== undefined) {\n            maskReferences.push(result);\n          }\n        }\n        effect.maskReferences = maskReferences;\n      }\n      switch (effect.type()) {\n        case EffectType.Fill:\n          if ((effect as FillEffect).fillMask !== undefined) {\n            const ID = (effect as FillEffect).fillMask.id;\n            const result = maskMap.get(ID);\n            if (result !== undefined) {\n              (effect as FillEffect).fillMask = result;\n            }\n          }\n          break;\n        case EffectType.Stroke: {\n          const strokeEffect = effect as StrokeEffect;\n          if ((strokeEffect.path! = undefined)) {\n            const ID = strokeEffect.path.id;\n            const result = maskMap.get(ID);\n            if (result !== undefined) {\n              strokeEffect.path = result;\n            }\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n  }\n\n  if (layer.type() === LayerType.Text) {\n    const { pathOption } = layer as TextLayer;\n    if (!!pathOption?.path) {\n      const ID = pathOption.path.id;\n      const result = maskMap.get(ID);\n      if (result !== undefined) {\n        pathOption.path = result;\n      }\n    }\n  }\n};\n\nexport const hasTrackMatte = (type: TrackMatteType): boolean => {\n  switch (type) {\n    case TrackMatteType.Alpha:\n    case TrackMatteType.AlphaInverted:\n      return true;\n    default:\n      return false;\n  }\n};\n","import { ByteArray } from '../utils/byte-array';\nimport { TagCode } from '../types';\nimport { Context } from '../context';\nimport { readVideoComposition } from './video-composition-tag';\nimport { readVectorComposition } from './vector-composition-tag';\n\nexport function readTagsOfFile(byteArray: ByteArray, code: TagCode, context: Context): void {\n  switch (code) {\n    case TagCode.VectorCompositionBlock:\n      context.compositions.push(readVectorComposition(byteArray));\n      break;\n    case TagCode.VideoCompositionBlock:\n      context.compositions.push(readVideoComposition(byteArray));\n      break;\n    default:\n      break;\n  }\n}\n","import { LayerType } from '../base/layer';\nimport { PreComposeLayer } from '../base/pre-compose-layer';\nimport { Transform2D } from '../base/transform-2d';\nimport { ErrorCode } from '../base/utils/error-map';\nimport { Log } from '../base/utils/log';\nimport { VectorComposition } from '../base/vector-composition';\nimport { VideoComposition } from '../base/video-composition';\nimport { VideoSequence } from '../base/video-sequence';\nimport { CompositionType } from '../codec/types';\nimport { concatArrayBuffers2Uint8Array } from '../codec/utils/byte-utils';\nimport { PAGFile } from '../pag-file';\n\nexport interface Matrix {\n  width: number;\n  height: number;\n  frameRate: number;\n  transform: Transform2D;\n  duration: number;\n  hasAlpha: boolean;\n  videoWidth: number;\n  videoHeight: number;\n  alphaStartX?: number;\n  alphaStartY?: number;\n}\n\nexport class VideoData {\n  public static create(file: PAGFile) {\n    if (!file) Log.error(ErrorCode.NotPagFile);\n    const videoData = new VideoData();\n    if (file.mainComposition.type() === CompositionType.Video) {\n      videoData.getVideoDataFromVideoComposition(file.mainComposition as VideoComposition);\n    } else if (file.mainComposition.type() === CompositionType.Vector) {\n      videoData.getVideoDataFromVectorComposition(file.mainComposition as VectorComposition);\n    }\n    return videoData;\n  }\n\n  public matrix: Matrix = {\n    width: 0,\n    height: 0,\n    frameRate: 0,\n    duration: 0,\n    hasAlpha: false,\n    transform: new Transform2D(),\n    videoWidth: 0,\n    videoHeight: 0,\n  };\n  public sequence: VideoSequence;\n\n  public getH264Raw() {\n    if (!this.sequence) Log.error(ErrorCode.NotSequence);\n    const header = this.sequence.headers.map((header) => header.data.data());\n    const body = this.sequence.frames.map((frame) => frame.fileBytes.data.data());\n    const buffers = [...header, ...body];\n    const h264Raw = concatArrayBuffers2Uint8Array(buffers);\n    return h264Raw;\n  }\n\n  public getPTS() {\n    if (!this.sequence) return;\n    const pts = this.sequence.frames.map((frame) => frame.frame);\n    return pts;\n  }\n\n  private getVideoDataFromVideoComposition(composition: VideoComposition) {\n    if (composition.sequences.length < 1) Log.error(ErrorCode.NotSequence);\n    this.matrix.width = composition.width;\n    this.matrix.height = composition.height;\n    this.matrix.frameRate = composition.frameRate;\n    this.matrix.duration = composition.duration;\n    this.matrix.videoWidth = composition.width;\n    this.matrix.videoHeight = composition.height;\n    this.matrix.hasAlpha = !!composition.hasAlpha;\n    const sequence = composition.sequences[composition.sequences.length - 1];\n    this.sequence = sequence;\n    this.matrix.transform = Transform2D.createDefaultTransform2D();\n  }\n\n  private getVideoDataFromVectorComposition(composition: VectorComposition) {\n    let sequencesCount = 0;\n    for (const layer of composition.layers) {\n      if (layer.type() !== LayerType.PreCompose) continue;\n\n      const composition = (layer as PreComposeLayer).composition as VideoComposition;\n      if (composition.type() === CompositionType.Video && composition.sequences.length >= 1) {\n        sequencesCount += 1;\n      }\n\n      if (sequencesCount > 1) {\n        Log.error(ErrorCode.NotSupportMultipleSequence);\n      }\n    }\n    if (sequencesCount < 1) {\n      Log.error(ErrorCode.NotSequence);\n    }\n\n    this.matrix.width = composition.width;\n    this.matrix.height = composition.height;\n    this.matrix.frameRate = composition.frameRate;\n    this.matrix.duration = composition.duration;\n\n    for (const layer of composition.layers) {\n      if (layer.type() !== LayerType.PreCompose) continue;\n\n      const videoComposition = (layer as PreComposeLayer).composition as VideoComposition;\n      if (videoComposition.type() !== CompositionType.Video && videoComposition.sequences.length < 1) continue;\n      this.matrix.videoWidth = videoComposition.width;\n      this.matrix.videoHeight = videoComposition.height;\n      this.matrix.hasAlpha = !!videoComposition.hasAlpha;\n      const sequence = videoComposition.sequences[videoComposition.sequences.length - 1];\n      this.sequence = sequence;\n      this.matrix.transform = (layer as PreComposeLayer).transform;\n      break;\n    }\n  }\n}\n","export class NALU {\n  public static ndr = 1;\n  public static idr = 5;\n  public static sei = 6;\n  public static sps = 7;\n  public static pps = 8;\n  public static aud = 9;\n\n  public static get TYPES() {\n    return {\n      [NALU.idr]: 'IDR',\n      [NALU.sei]: 'SEI',\n      [NALU.sps]: 'SPS',\n      [NALU.pps]: 'PPS',\n      [NALU.ndr]: 'NDR',\n      [NALU.aud]: 'AUD',\n    };\n  }\n\n  public static getNaluType(nalu: NALU) {\n    if (nalu.nalUnitType in NALU.TYPES) {\n      return NALU.TYPES[nalu.nalUnitType];\n    }\n    return 'UNKNOWN';\n  }\n\n  public payload: Uint8Array;\n  public nalRefIdc: number;\n  public nalUnitType: number;\n  public isVcl: boolean;\n  public sliceType: number;\n  public firstMbInSlice: boolean;\n\n  constructor(data: Uint8Array) {\n    this.payload = data;\n    this.nalRefIdc = (this.payload[0] & 0x60) >> 5; // nal_ref_idc\n    this.nalUnitType = this.payload[0] & 0x1f;\n    this.isVcl = this.nalUnitType === 1 || this.nalUnitType === 5;\n    this.sliceType = 0; // slice_type\n    this.firstMbInSlice = false; // first_mb_in_slice\n  }\n\n  public toString() {\n    return `${NALU.TYPES[this.nalUnitType]}: NRI: ${this.nalRefIdc}`;\n  }\n\n  public isKeyframe() {\n    return this.nalUnitType === NALU.idr;\n  }\n\n  public getPayloadSize() {\n    return this.payload.byteLength;\n  }\n\n  public getSize() {\n    return 4 + this.getPayloadSize();\n  }\n\n  public getData() {\n    const result = new Uint8Array(this.getSize());\n    const view = new DataView(result.buffer);\n    view.setUint32(0, this.getSize() - 4);\n    result.set(this.payload, 4);\n    return result;\n  }\n}\n","export class ExpGolomb {\n  private data: Uint8Array;\n  private index: number;\n  private bitLength: number;\n\n  constructor(data: Uint8Array) {\n    this.data = data;\n    this.index = 0;\n    this.bitLength = data.byteLength * 8;\n  }\n\n  public get bitsAvailable() {\n    return this.bitLength - this.index;\n  }\n\n  public skipBits(size: number) {\n    if (this.bitsAvailable < size) {\n      return false;\n    }\n    this.index += size;\n  }\n\n  public readBits(size: number, moveIndex = true) {\n    const result = this.getBits(size, this.index, moveIndex);\n    return result;\n  }\n\n  public skipLZ() {\n    let leadingZeroCount;\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitLength - this.index; ++leadingZeroCount) {\n      if (this.getBits(1, this.index + leadingZeroCount, false) !== 0) {\n        this.index += leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    return leadingZeroCount;\n  }\n\n  public skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  public skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  public readUEG() {\n    const prefix = this.skipLZ();\n    return this.readBits(prefix + 1) - 1;\n  }\n\n  public readEG() {\n    const value = this.readUEG();\n    if (0x01 & value) {\n      return (1 + value) >>> 1;\n    }\n    return -1 * (value >>> 1);\n  }\n\n  public readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  public readUByte(numberOfBytes = 1) {\n    return this.readBits(numberOfBytes * 8);\n  }\n\n  public readUShort() {\n    return this.readBits(16);\n  }\n\n  public readUInt() {\n    return this.readBits(32);\n  }\n\n  public readUE() {\n    let r = 0;\n    let i = 0;\n    while (this.readBits(1) === 0 && i < 32 && this.bitsAvailable) {\n      i += 1;\n    }\n    r = this.readBits(i);\n    r += (1 << i) - 1;\n    return r;\n  }\n\n  private getBits(size: number, offsetBits: number, moveIndex = true) {\n    if (this.bitsAvailable < size) {\n      return 0;\n    }\n    const offset = offsetBits % 8;\n    const byte = this.data[(offsetBits / 8) | 0] & (0xff >>> offset);\n    const bits = 8 - offset;\n    if (bits >= size) {\n      if (moveIndex) {\n        this.index += size;\n      }\n      return byte >> (bits - size);\n    }\n    if (moveIndex) {\n      this.index += bits;\n    }\n    const nextSize = size - bits;\n    return (byte << nextSize) | this.getBits(nextSize, offsetBits + bits, moveIndex);\n  }\n}\n","import { NALU } from './nalu';\nimport { ExpGolomb } from './exp-golomb';\nimport { Log } from '../base/utils/log';\nimport { ErrorCode } from '../base/utils/error-map';\nimport { VideoSequence } from '../base/video-sequence';\n\ntype Units = Array<NALU>;\nexport interface H264Frame {\n  units: Units;\n  isKeyFrame: boolean;\n}\nexport class H264Parser {\n  public static getNaluFromSequence(sequence: VideoSequence): Array<Uint8Array> {\n    return [\n      ...sequence.headers.map((header) => new Uint8Array(header.data.data(), 4)),\n      ...sequence.frames.map((frame) => new Uint8Array(frame.fileBytes.data.data(), 4)),\n    ];\n  }\n\n  public static getH264Frames(nalus): H264Frame[] {\n    if (nalus.length < 1) Log.error(ErrorCode.NotNalu);\n    const frames: H264Frame[] = [];\n    let units: Array<NALU> = [];\n    let isKeyFrame = false;\n    let isVcl = false;\n    for (const nalu of nalus) {\n      const unit = new NALU(nalu);\n      if (unit.nalUnitType === NALU.idr || unit.nalUnitType === NALU.ndr) {\n        H264Parser.parseHeader(unit);\n      }\n      if (units.length && isVcl && (unit.firstMbInSlice || !unit.isVcl)) {\n        frames.push({ units, isKeyFrame });\n        units = [];\n        isKeyFrame = false;\n        isVcl = false;\n      }\n      units.push(unit);\n      isKeyFrame = isKeyFrame || unit.isKeyframe();\n      isVcl = isVcl || unit.isVcl;\n    }\n    if (units.length > 0) {\n      if (isVcl) {\n        frames.push({ units, isKeyFrame });\n      } else {\n        const last = frames.length - 1;\n        frames[last].units = frames[last].units.concat(units);\n      }\n    }\n    return frames;\n  }\n\n  public static parseHeader(nalu: NALU) {\n    const decoder = new ExpGolomb(nalu.payload);\n    decoder.readUByte(); // skip NALu type\n    nalu.firstMbInSlice = decoder.readUEG() === 0;\n    nalu.sliceType = decoder.readUEG();\n  }\n\n  public static parseSPS(nalu) {\n    const { width, height } = H264Parser.readSPS(nalu);\n    const sps = new Uint8Array(nalu);\n    let codec = 'avc1.';\n    const codecarray = new DataView(nalu.buffer, nalu.byteOffset + 1, 4);\n    for (let i = 0; i < 3; ++i) {\n      let h = codecarray.getUint8(i).toString(16);\n      if (h.length < 2) {\n        h = `0${h}`;\n      }\n      codec += h;\n    }\n    return { sps, codec, width, height };\n  }\n\n  public static skipScalingList(decoder, count) {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = decoder.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  public static readSPS(data) {\n    const profileIdcMap = [100, 110, 122, 244, 44, 83, 86, 118, 128];\n    const decoder = new ExpGolomb(data);\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let sarScale = 1;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    decoder.readBits(1); // forbidden_zero_bit\n    decoder.readBits(2); // nal_ref_idc\n    decoder.readBits(5); // nal_unit_type\n    const profileIdc = decoder.readUByte(); // profile_idc\n    decoder.readBits(6); // constraint_set[0-5]_flag, u(6)\n    decoder.readBits(2); // reserved_zero_3bits u(2),\n    decoder.readUByte(); // level_idc u(8)\n    decoder.readUE(); // seq_parameter_set_id\n\n    if (profileIdcMap.indexOf(profileIdc) > -1) {\n      const chromaFormatIdc = decoder.readUE();\n      if (chromaFormatIdc === 3) {\n        decoder.skipBits(1); // separate_colour_plane_flag\n      }\n      decoder.readUE(); // bit_depth_luma_minus8\n      decoder.readUE(); // bit_depth_chroma_minus8\n      decoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      const seqScalingMatrixPresentFlag = decoder.readBoolean();\n      if (seqScalingMatrixPresentFlag) {\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (let i = 0; i < scalingListCount; ++i) {\n          if (decoder.readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              H264Parser.skipScalingList(decoder, 16);\n            } else {\n              H264Parser.skipScalingList(decoder, 64);\n            }\n          }\n        }\n      }\n    }\n    decoder.readUE(); // log2_max_frame_num_minus4\n    const picOrderCntType = decoder.readUE();\n    if (picOrderCntType === 0) {\n      decoder.readUE(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      decoder.skipBits(1); // delta_pic_order_always_zero_flag\n      decoder.readUE(); // offset_for_non_ref_pic\n      decoder.readUE(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = decoder.readUE();\n      for (let i = 0; i < numRefFramesInPicOrderCntCycle; ++i) {\n        decoder.readUE(); // offset_for_ref_frame[ i ]\n      }\n    }\n    decoder.readUE(); // max_num_ref_frames\n    decoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = decoder.readUE();\n    const picHeightInMapUnitsMinus1 = decoder.readUE();\n    const frameMbsOnlyFlag = decoder.readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      decoder.skipBits(1); // mb_adaptive_frame_field_flag\n    }\n    decoder.readBits(1); // direct_8x8_inference_flag\n    const frameCroppingFlag = decoder.readBoolean();\n    if (frameCroppingFlag) {\n      frameCropLeftOffset = decoder.readUE();\n      frameCropRightOffset = decoder.readUE();\n      frameCropTopOffset = decoder.readUE();\n      frameCropBottomOffset = decoder.readUE();\n    }\n    const vuiParametersPresentFlag = decoder.readBoolean();\n    if (vuiParametersPresentFlag) {\n      const aspectRatioInfoPresentFlag = decoder.readBoolean();\n      if (aspectRatioInfoPresentFlag) {\n        let sarRatio;\n        const aspectRatioIdc = decoder.readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            sarRatio = [1, 1];\n            break;\n          case 2:\n            sarRatio = [12, 11];\n            break;\n          case 3:\n            sarRatio = [10, 11];\n            break;\n          case 4:\n            sarRatio = [16, 11];\n            break;\n          case 5:\n            sarRatio = [40, 33];\n            break;\n          case 6:\n            sarRatio = [24, 11];\n            break;\n          case 7:\n            sarRatio = [20, 11];\n            break;\n          case 8:\n            sarRatio = [32, 11];\n            break;\n          case 9:\n            sarRatio = [80, 33];\n            break;\n          case 10:\n            sarRatio = [18, 11];\n            break;\n          case 11:\n            sarRatio = [15, 11];\n            break;\n          case 12:\n            sarRatio = [64, 33];\n            break;\n          case 13:\n            sarRatio = [160, 99];\n            break;\n          case 14:\n            sarRatio = [4, 3];\n            break;\n          case 15:\n            sarRatio = [3, 2];\n            break;\n          case 16:\n            sarRatio = [2, 1];\n            break;\n          case 255: {\n            sarRatio = [\n              (decoder.readUByte() << 8) | decoder.readUByte(),\n              (decoder.readUByte() << 8) | decoder.readUByte(),\n            ];\n            break;\n          }\n        }\n        if (sarRatio) {\n          sarScale = sarRatio[0] / sarRatio[1];\n        }\n      }\n    }\n    return {\n      width: Math.ceil(\n        ((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale,\n      ),\n      height:\n        (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 -\n        (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n    };\n  }\n}\n","import { Mp4Track } from './h264-remuxer';\n\nconst CORRECTION_UTC = 2082873600; // 1904-01-01 与 1970-1-1 相差的秒数\n\nconst decimal2HexadecimalArray = (payload: number) => [\n  payload >> 24,\n  (payload >> 16) & 0xff,\n  (payload >> 8) & 0xff,\n  payload & 0xff,\n];\n\nconst getCharCode = (name: string) => [name.charCodeAt(0), name.charCodeAt(1), name.charCodeAt(2), name.charCodeAt(3)];\n\nexport class Mp4Generator {\n  private static hdlrTypes = {\n    video: new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0x76,\n      0x69,\n      0x64,\n      0x65, // handler_type: 'vide'\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x56,\n      0x69,\n      0x64,\n      0x65,\n      0x6f,\n      0x48,\n      0x61,\n      0x6e,\n      0x64,\n      0x6c,\n      0x65,\n      0x72,\n      0x00, // name: 'VideoHandler'\n    ]),\n    audio: new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0x73,\n      0x6f,\n      0x75,\n      0x6e, // handler_type: 'soun'\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x53,\n      0x6f,\n      0x75,\n      0x6e,\n      0x64,\n      0x48,\n      0x61,\n      0x6e,\n      0x64,\n      0x6c,\n      0x65,\n      0x72,\n      0x00, // name: 'SoundHandler'\n    ]),\n  };\n\n  private static fullbox = new Uint8Array([\n    0x00, // version\n    0x00,\n    0x00,\n    0x00, // flags\n    0x00,\n    0x00,\n    0x00,\n    0x00, // entry_count\n  ]);\n\n  private static stsc = Mp4Generator.fullbox;\n\n  private static stco = Mp4Generator.fullbox;\n\n  private static stsz = new Uint8Array([\n    0x00, // version\n    0x00,\n    0x00,\n    0x00, // flags\n    0x00,\n    0x00,\n    0x00,\n    0x00, // sample_size\n    0x00,\n    0x00,\n    0x00,\n    0x00, // sample_count\n  ]);\n\n  private static vmhd = new Uint8Array([\n    0x00, // version\n    0x00,\n    0x00,\n    0x01, // flags\n    0x00,\n    0x00, // graphicsmode\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00, // opcolor\n  ]);\n\n  private static smhd = new Uint8Array([\n    0x00, // version\n    0x00,\n    0x00,\n    0x00, // flags\n    0x00,\n    0x00, // balance\n    0x00,\n    0x00, // reserved\n  ]);\n\n  private static stsd = new Uint8Array([\n    0x00, // version 0\n    0x00,\n    0x00,\n    0x00, // flags\n    0x00,\n    0x00,\n    0x00,\n    0x01, // entry_count\n  ]);\n\n  private static box(type: any[], ...payload: Uint8Array[]): Uint8Array {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    while (i) {\n      i -= 1;\n      size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = (size >> 24) & 0xff;\n    result[1] = (size >> 16) & 0xff;\n    result[2] = (size >> 8) & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; ++i) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n\n  private types = {\n    avc1: [],\n    avcC: [],\n    btrt: [],\n    ctts: [],\n    dinf: [],\n    dref: [],\n    edts: [],\n    elst: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [],\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    stss: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: [],\n    smhd: [],\n  };\n\n  private dinf: Uint8Array;\n\n  constructor() {\n    Object.keys(this.types).forEach((type) => {\n      if (Object.prototype.hasOwnProperty.call(this.types, type)) {\n        this.types[type] = getCharCode(type);\n      }\n    });\n\n    const dref = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x00,\n      0x00,\n      0x00,\n      0x01, // entry_count\n      0x00,\n      0x00,\n      0x00,\n      0x0c, // entry_size\n      0x75,\n      0x72,\n      0x6c,\n      0x20, // 'url' type\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x01, // entry_flags\n    ]);\n    this.dinf = Mp4Generator.box(this.types.dinf, Mp4Generator.box(this.types.dref, dref));\n  }\n\n  public ftyp() {\n    return Mp4Generator.box(\n      this.types.ftyp,\n      new Uint8Array(getCharCode('isom')), // major_brand\n      new Uint8Array([0, 0, 0, 1]), // minor_version\n      new Uint8Array(getCharCode('isom')), // compatible_brands\n      new Uint8Array(getCharCode('iso2')),\n      new Uint8Array(getCharCode('avc1')),\n      new Uint8Array(getCharCode('mp41')),\n    );\n  }\n\n  public moov(tracks: Mp4Track[], duration: number, timescale: number) {\n    let i = tracks.length;\n    const boxes = [];\n\n    while (i) {\n      i -= 1;\n      boxes[i] = this.trak(tracks[i]);\n    }\n\n    return Mp4Generator.box.apply(\n      null,\n      [this.types.moov, this.mvhd(timescale, duration)].concat(boxes).concat(this.mvex(tracks)),\n    );\n  }\n\n  public moof(sequence_number: number, baseMediaDecodeTime: number, track: Mp4Track) {\n    return Mp4Generator.box(this.types.moof, this.mfhd(sequence_number), this.traf(baseMediaDecodeTime, track));\n  }\n\n  public mdat(data: Uint8Array) {\n    return Mp4Generator.box(this.types.mdat, data);\n  }\n\n  private hdlr(type: string) {\n    return Mp4Generator.box(this.types.hdlr, Mp4Generator.hdlrTypes[type]);\n  }\n\n  private mdhd(track: Mp4Track) {\n    return Mp4Generator.box(\n      this.types.mdhd,\n      new Uint8Array([\n        0x00, // version 0\n        0x00,\n        0x00,\n        0x00, // flags\n        ...decimal2HexadecimalArray(Math.floor(Date.now() / 1000 + CORRECTION_UTC)), // creation_time\n        ...decimal2HexadecimalArray(Math.floor(Date.now() / 1000 + CORRECTION_UTC)), // modification_time\n        ...decimal2HexadecimalArray(track.timescale), // timescale\n        ...decimal2HexadecimalArray(0), // duration\n        0x55,\n        0xc4, // 'und' language (undetermined)\n        0x00,\n        0x00,\n      ]),\n    );\n  }\n\n  private mdia(track: Mp4Track) {\n    return Mp4Generator.box(this.types.mdia, this.mdhd(track), this.hdlr(track.type), this.minf(track));\n  }\n\n  private mfhd(sequenceNumber: number) {\n    return Mp4Generator.box(\n      this.types.mfhd,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00,\n        0x00, // flags\n        sequenceNumber >> 24,\n        (sequenceNumber >> 16) & 0xff,\n        (sequenceNumber >> 8) & 0xff,\n        sequenceNumber & 0xff, // sequence_number\n      ]),\n    );\n  }\n\n  private minf(track: Mp4Track) {\n    if (track.type === 'audio') {\n      return Mp4Generator.box(\n        this.types.minf,\n        Mp4Generator.box(this.types.smhd, Mp4Generator.smhd),\n        this.dinf,\n        this.stbl(track),\n      );\n    }\n    return Mp4Generator.box(\n      this.types.minf,\n      Mp4Generator.box(this.types.vmhd, Mp4Generator.vmhd),\n      this.dinf,\n      this.stbl(track),\n    );\n  }\n\n  private mvex(tracks: Mp4Track[]) {\n    let i = tracks.length;\n    const boxes = [];\n\n    while (i) {\n      i -= 1;\n      boxes[i] = this.trex(tracks[i]);\n    }\n    return Mp4Generator.box.apply(null, [this.types.mvex].concat(boxes));\n  }\n\n  private mvhd(timescale: number, duration: number) {\n    const bytes = new Uint8Array([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      ...decimal2HexadecimalArray(Math.floor(Date.now() / 1000 + CORRECTION_UTC)), // creation_time\n      ...decimal2HexadecimalArray(Math.floor(Date.now() / 1000 + CORRECTION_UTC)), // modification_time\n      ...decimal2HexadecimalArray(timescale), // timescale\n      ...decimal2HexadecimalArray(duration), // duration\n      0x00,\n      0x01,\n      0x00,\n      0x00, // 1.0 rate\n      0x01,\n      0x00, // 1.0 volume\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x00,\n      0x00,\n      0x00, // reserved\n      0x00,\n      0x01,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x01,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x40,\n      0x00,\n      0x00,\n      0x00, // transformation: unity matrix\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00,\n      0x00, // pre_defined\n      0x00,\n      0x00,\n      0x00,\n      0x02, // next_track_ID\n    ]);\n    return Mp4Generator.box(this.types.mvhd, bytes);\n  }\n\n  private sdtp(track: Mp4Track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let flags;\n    let i;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = (flags.dependsOn << 4) | (flags.isDependedOn << 2) | flags.hasRedundancy;\n    }\n\n    return Mp4Generator.box(this.types.sdtp, bytes);\n  }\n\n  private stbl(track: Mp4Track) {\n    return Mp4Generator.box(\n      this.types.stbl,\n      this.stsd(track),\n      this.stts(track),\n      this.ctts(track),\n      this.stss(track),\n      Mp4Generator.box(this.types.stsc, Mp4Generator.stsc),\n      Mp4Generator.box(this.types.stsz, Mp4Generator.stsz),\n      Mp4Generator.box(this.types.stco, Mp4Generator.stco),\n    );\n  }\n\n  private avc1(track: Mp4Track) {\n    let sps = [];\n    let pps = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push((len >>> 8) & 0xff);\n      sps.push(len & 0xff);\n      sps = sps.concat(Array.prototype.slice.call(data)); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push((len >>> 8) & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n\n    const avcc = Mp4Generator.box(\n      this.types.avcC,\n      new Uint8Array(\n        [\n          0x01, // version\n          sps[3], // profile\n          sps[4], // profile compat\n          sps[5], // level\n          0xfc | 3, // lengthSizeMinusOne, hard-coded to 4 bytes\n          0xe0 | track.sps.length, // 3bit reserved (111) + numOfSequenceParameterSets\n        ]\n          .concat(sps)\n          .concat([\n            track.pps.length, // numOfPictureParameterSets\n          ])\n          .concat(pps),\n      ),\n    ); // \"PPS\"\n    const { width } = track;\n    const { height } = track;\n    return Mp4Generator.box(\n      this.types.avc1,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // data_reference_index\n        0x00,\n        0x00, // pre_defined\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // pre_defined\n        (width >> 8) & 0xff,\n        width & 0xff, // width\n        (height >> 8) & 0xff,\n        height & 0xff, // height\n        0x00,\n        0x48,\n        0x00,\n        0x00, // horizresolution\n        0x00,\n        0x48,\n        0x00,\n        0x00, // vertresolution\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // frame_count\n        0x12,\n        0x62,\n        0x69,\n        0x6e,\n        0x65, // binelpro.ru\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // compressorname\n        0x00,\n        0x18, // depth = 24\n        0xff,\n        0xff,\n      ]), // pre_defined = -1\n      avcc,\n    );\n  }\n\n  private esds(track) {\n    const configlen = track.config.byteLength;\n    const data = new Uint8Array(26 + configlen + 3);\n    data.set([\n      0x00, // version 0\n      0x00,\n      0x00,\n      0x00, // flags\n      0x03, // descriptor_type\n      0x17 + configlen, // length\n      0x00,\n      0x01, // es_id\n      0x00, // stream_priority\n      0x04, // descriptor_type\n      0x0f + configlen, // length\n      0x40, // codec : mpeg4_audio\n      0x15, // stream_type\n      0x00,\n      0x00,\n      0x00, // buffer_size\n      0x00,\n      0x00,\n      0x00,\n      0x00, // maxBitrate\n      0x00,\n      0x00,\n      0x00,\n      0x00, // avgBitrate\n      0x05, // descriptor_type\n      configlen,\n    ]);\n    data.set(track.config, 26);\n    data.set([0x06, 0x01, 0x02], 26 + configlen);\n    return data;\n  }\n\n  private mp4a(track) {\n    const { audiosamplerate } = track;\n    return Mp4Generator.box(\n      this.types.mp4a,\n      new Uint8Array([\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01, // data_reference_index\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        track.channelCount, // channelcount\n        0x00,\n        0x10, // sampleSize:16bits\n        0x00,\n        0x00, // pre_defined\n        0x00,\n        0x00, // reserved2\n        (audiosamplerate >> 8) & 0xff,\n        audiosamplerate & 0xff, //\n        0x00,\n        0x00,\n      ]),\n      Mp4Generator.box(this.types.esds, this.esds(track)),\n    );\n  }\n\n  private stsd(track: Mp4Track) {\n    if (track.type === 'audio') {\n      return Mp4Generator.box(this.types.stsd, Mp4Generator.stsd, this.mp4a(track));\n    }\n    return Mp4Generator.box(this.types.stsd, Mp4Generator.stsd, this.avc1(track));\n  }\n\n  private tkhd(track) {\n    return Mp4Generator.box(\n      this.types.tkhd,\n      new Uint8Array([\n        0x00, // version 0\n        0x00,\n        0x00,\n        0x01, // flags\n        ...decimal2HexadecimalArray(Math.floor(Date.now() / 1000 + CORRECTION_UTC)), // creation_time\n        ...decimal2HexadecimalArray(Math.floor(Date.now() / 1000 + CORRECTION_UTC)), // modification_time\n        ...decimal2HexadecimalArray(track.id), // track_ID\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        ...decimal2HexadecimalArray(track.duration), // duration\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x00, // layer\n        0x00,\n        0x00, // alternate_group\n        (track.volume >> 0) & 0xff,\n        (((track.volume % 1) * 10) >> 0) & 0xff, // track volume // FIXME\n        0x00,\n        0x00, // reserved\n        0x00,\n        0x01,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x01,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x00,\n        0x40,\n        0x00,\n        0x00,\n        0x00, // transformation: unity matrix\n        (track.width >> 8) & 0xff,\n        track.width & 0xff,\n        0x00,\n        0x00, // width\n        (track.height >> 8) & 0xff,\n        track.height & 0xff,\n        0x00,\n        0x00, // height\n      ]),\n    );\n  }\n\n  private traf(baseMediaDecodeTime: number, track: Mp4Track) {\n    const sampleDependencyTable = this.sdtp(track);\n    const { id } = track;\n    return Mp4Generator.box(\n      this.types.traf,\n      Mp4Generator.box(\n        this.types.tfhd,\n        new Uint8Array([\n          0x00, // version 0\n          0x00,\n          0x00,\n          0x00, // flags\n          id >> 24,\n          (id >> 16) & 0xff,\n          (id >> 8) & 0xff,\n          id & 0xff, // track_ID\n        ]),\n      ),\n      Mp4Generator.box(\n        this.types.tfdt,\n        new Uint8Array([\n          0x00, // version 0\n          0x00,\n          0x00,\n          0x00, // flags\n          baseMediaDecodeTime >> 24,\n          (baseMediaDecodeTime >> 16) & 0xff,\n          (baseMediaDecodeTime >> 8) & 0xff,\n          baseMediaDecodeTime & 0xff, // baseMediaDecodeTime\n        ]),\n      ),\n      this.trun(\n        track,\n        sampleDependencyTable.length +\n          16 + // tfhd\n          16 + // tfdt\n          8 + // traf header\n          16 + // mfhd\n          8 + // moof header\n          8,\n      ), // mdat header\n      sampleDependencyTable,\n    );\n  }\n\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */\n  private trak(track: Mp4Track) {\n    track.duration = track.duration || 0xffffffff;\n    return Mp4Generator.box(this.types.trak, this.tkhd(track), this.edts(track), this.mdia(track));\n  }\n\n  private edts(track: Mp4Track) {\n    return Mp4Generator.box(this.types.edts, this.elst(track));\n  }\n\n  private elst(track: Mp4Track) {\n    const sampleCount = track.samples.length;\n    const sampleDelta = Math.floor(track.duration / sampleCount);\n    const buffer = [\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      ...decimal2HexadecimalArray(1), // entry_count\n      ...decimal2HexadecimalArray(track.duration),\n      ...decimal2HexadecimalArray(track.implicitOffset * sampleDelta),\n      0x00,\n      0x01, // media_rate_integer\n      0x00,\n      0x00, // media_rate_integer\n    ];\n    return Mp4Generator.box(this.types.elst, new Uint8Array(buffer));\n  }\n\n  private trex(track: Mp4Track) {\n    const { id } = track;\n    return Mp4Generator.box(\n      this.types.trex,\n      new Uint8Array([\n        0x00, // version 0\n        0x00,\n        0x00,\n        0x00, // flags\n        id >> 24,\n        (id >> 16) & 0xff,\n        (id >> 8) & 0xff,\n        id & 0xff, // track_ID\n        0x00,\n        0x00,\n        0x00,\n        0x01, // default_sample_description_index\n        0x00,\n        0x00,\n        0x00,\n        0x00, // default_sample_duration\n        0x00,\n        0x00,\n        0x00,\n        0x00, // default_sample_size\n        0x00,\n        0x01,\n        0x00,\n        0x01, // default_sample_flags\n      ]),\n    );\n  }\n\n  private trun(track: Mp4Track, offset: number) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set(\n      [\n        0x00, // version 0\n        0x00,\n        0x0f,\n        0x01, // flags\n        (len >>> 24) & 0xff,\n        (len >>> 16) & 0xff,\n        (len >>> 8) & 0xff,\n        len & 0xff, // sample_count\n        (offset >>> 24) & 0xff,\n        (offset >>> 16) & 0xff,\n        (offset >>> 8) & 0xff,\n        offset & 0xff, // data_offset\n      ],\n      0,\n    );\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set(\n        [\n          (duration >>> 24) & 0xff,\n          (duration >>> 16) & 0xff,\n          (duration >>> 8) & 0xff,\n          duration & 0xff, // sample_duration\n          (size >>> 24) & 0xff,\n          (size >>> 16) & 0xff,\n          (size >>> 8) & 0xff,\n          size & 0xff, // sample_size\n          (flags.isLeading << 2) | flags.dependsOn,\n          (flags.isDependedOn << 6) | (flags.hasRedundancy << 4) | (flags.paddingValue << 1) | flags.isNonSync,\n          flags.degradPrio & (0xf0 << 8),\n          flags.degradPrio & 0x0f, // sample_flags\n          (cts >>> 24) & 0xff,\n          (cts >>> 16) & 0xff,\n          (cts >>> 8) & 0xff,\n          cts & 0xff, // sample_composition_time_offset\n        ],\n        12 + 16 * i,\n      );\n    }\n    return Mp4Generator.box(this.types.trun, array);\n  }\n\n  private stts(track: Mp4Track) {\n    const sampleCount = track.samples.length;\n    const sampleDelta = Math.floor(track.duration / sampleCount);\n    const buffer = [\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      ...decimal2HexadecimalArray(1), // entry_count\n      ...decimal2HexadecimalArray(sampleCount), // sample_count\n      ...decimal2HexadecimalArray(sampleDelta), // sample_offset\n    ];\n    return Mp4Generator.box(this.types.stts, new Uint8Array(buffer));\n  }\n\n  private ctts(track: Mp4Track) {\n    const sampleCount = track.pts.length;\n    const sampleDelta = Math.floor(track.duration / sampleCount);\n    const buffer = [\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      ...decimal2HexadecimalArray(sampleCount), // entry_count\n    ];\n    for (let i = 0; i < sampleCount; i++) {\n      buffer.push(...decimal2HexadecimalArray(1)); // sample_count\n      const dts = i * sampleDelta;\n      const pts = track.pts[i] * sampleDelta + track.implicitOffset * sampleDelta;\n      buffer.push(...decimal2HexadecimalArray(pts - dts)); // sample_offset\n    }\n    return Mp4Generator.box(this.types.ctts, new Uint8Array(buffer));\n  }\n\n  private stss(track: Mp4Track) {\n    const iFrames = track.samples.filter((sample) => sample.flags.isKeyFrame).map((sample) => sample.index + 1);\n    const buffer = [\n      0x00, // version\n      0x00,\n      0x00,\n      0x00, // flags\n      ...decimal2HexadecimalArray(iFrames.length),\n    ];\n    for (const iFrame of iFrames) {\n      buffer.push(...decimal2HexadecimalArray(iFrame));\n    }\n    return Mp4Generator.box(this.types.stss, new Uint8Array(buffer));\n  }\n}\n","import { VideoData } from '../file/video-data';\nimport { H264Frame, H264Parser } from './h264-parser';\nimport { NALU } from './nalu';\nimport { Mp4Generator } from './mp4-generator';\nimport { concatUint8Arrays } from '../codec/utils/byte-utils';\nimport { Log } from '../base/utils/log';\nimport { ErrorCode } from '../base/utils/error-map';\n\nconst NALU_BASE_TYPES = [NALU.sps, NALU.pps, NALU.idr, NALU.ndr]; // 只解析基础 NALU\nconst SEQUENCE_NUMBER = 1;\nconst BASE_MEDIA_DECODE_TIME = 0;\nconst BASE_MEDIA_TIME_SCALE = 6000;\n\nexport interface Sample {\n  units: NALU[];\n  size: number;\n  keyFrame: boolean;\n}\n\nexport interface Mp4Sample {\n  index: number;\n  size: number;\n  duration: number;\n  cts: number;\n  flags: {\n    isLeading: number;\n    isDependedOn: number;\n    hasRedundancy: number;\n    degradPrio: number;\n    isNonSync: number;\n    dependsOn: number;\n    isKeyFrame: boolean;\n  };\n}\n\nexport interface Mp4Track {\n  id: number;\n  type: string;\n  len: number;\n  fragmented: boolean;\n  sps: Uint8Array[];\n  pps: Uint8Array[];\n  width: number;\n  height: number;\n  timescale: number;\n  duration: number;\n  samples: Mp4Sample[];\n  pts: number[];\n  codec: string;\n  fps: number;\n  implicitOffset: number;\n}\n\nlet trackId = 1;\n\nexport class H264Remuxer {\n  public static getTrackID() {\n    const id = trackId;\n    trackId += 1;\n    return id;\n  }\n\n  public static remux(frames: H264Frame[], videoData: VideoData) {\n    if (frames.length < 1) Log.error(ErrorCode.NotFrames);\n    const remuxer = new H264Remuxer();\n    remuxer.mp4track.timescale = BASE_MEDIA_TIME_SCALE;\n    remuxer.mp4track.duration = Math.floor((frames.length / videoData.matrix.frameRate) * BASE_MEDIA_TIME_SCALE);\n    remuxer.mp4track.fps = videoData.matrix.frameRate;\n    remuxer.mp4track.pts = videoData.getPTS();\n    remuxer.mp4track.implicitOffset = getImplicitOffset(remuxer.mp4track.pts); // 抵消 PTS 与 DTS 差值为负的情况\n    let readyToDecode = false;\n\n    for (const frame of frames) {\n      const units = frame.units.filter((unit) => NALU_BASE_TYPES.includes(unit.nalUnitType));\n      if (units.length < 1) continue;\n      const size = units.reduce((pre, cur) => pre + cur.getSize(), 0);\n      if (!remuxer.mp4track.sps) {\n        units.forEach((unit) => {\n          if (unit.nalUnitType === NALU.sps) {\n            const { sps, codec, width, height } = H264Parser.parseSPS(unit.payload);\n            remuxer.mp4track.width = width;\n            remuxer.mp4track.height = height;\n            remuxer.mp4track.sps = [sps];\n            remuxer.mp4track.codec = codec;\n          }\n        });\n        if (remuxer.mp4track.sps && remuxer.mp4track.pps) readyToDecode = true;\n      }\n      if (!remuxer.mp4track.pps) {\n        units.forEach((unit) => {\n          if (unit.nalUnitType === NALU.pps) {\n            remuxer.mp4track.pps = [new Uint8Array(unit.payload)];\n          }\n        });\n        if (remuxer.mp4track.sps && remuxer.mp4track.pps) readyToDecode = true;\n      }\n      if (readyToDecode) {\n        remuxer.mp4track.len += size;\n        remuxer.samples.push({\n          units,\n          size,\n          keyFrame: frame.isKeyFrame,\n        });\n      }\n    }\n    return remuxer;\n  }\n\n  public mp4track: Mp4Track = {\n    id: H264Remuxer.getTrackID(),\n    type: 'video',\n    len: 0,\n    fragmented: true,\n    sps: undefined,\n    pps: undefined,\n    width: 0,\n    height: 0,\n    timescale: 0,\n    duration: 0,\n    samples: [],\n    pts: [],\n    codec: '',\n    fps: 0,\n    implicitOffset: 0,\n  };\n  public samples: Sample[] = [];\n\n  public convertMp4() {\n    const payload = this.getPayload();\n    if (!payload) return;\n    const mp4Generator = new Mp4Generator();\n    const ftyp = mp4Generator.ftyp();\n    const moov = mp4Generator.moov([this.mp4track], this.mp4track.duration, this.mp4track.timescale);\n    const moof = mp4Generator.moof(SEQUENCE_NUMBER, BASE_MEDIA_DECODE_TIME, this.mp4track);\n    const mdat = mp4Generator.mdat(payload);\n\n    return concatUint8Arrays([ftyp, moov, moof, mdat]);\n  }\n\n  private getPayload() {\n    const payload = new Uint8Array(this.mp4track.len);\n    const sampleDelta = Math.floor(this.mp4track.duration / this.samples.length);\n    let offset = 0;\n    let count = 0;\n\n    for (const sample of this.samples) {\n      const { units } = sample;\n      const mp4Sample: Mp4Sample = {\n        index: count,\n        size: sample.size,\n        duration: sampleDelta,\n        cts: this.mp4track.pts[count] * sampleDelta + this.mp4track.implicitOffset * sampleDelta - count * sampleDelta,\n        flags: {\n          isLeading: 0,\n          isDependedOn: 0,\n          hasRedundancy: 0,\n          degradPrio: 0,\n          isNonSync: sample.keyFrame ? 0 : 1,\n          dependsOn: sample.keyFrame ? 2 : 1,\n          isKeyFrame: sample.keyFrame,\n        },\n      };\n\n      for (const unit of units) {\n        payload.set(unit.getData(), offset);\n        offset += unit.getSize();\n      }\n      this.mp4track.samples.push(mp4Sample);\n      count += 1;\n    }\n\n    if (!this.mp4track.samples.length) return;\n    return payload;\n  }\n}\n\nconst getImplicitOffset = (ptsList: number[]) => {\n  const offsetList = ptsList.map((pts, index) => pts - index).filter((offset) => offset < 0);\n  if (offsetList.length < 1) return 0;\n  return Math.abs(Math.min(...offsetList));\n};\n","import { Matrix, VideoData } from './file/video-data';\nimport { H264Parser } from './generator/h264-parser';\nimport { H264Remuxer } from './generator/h264-remuxer';\n\nexport interface Mp4Data {\n  matrix: Matrix;\n  sequenceInfo: SequenceInfo;\n  mp4Info: Mp4Info;\n  data: Uint8Array;\n  url?: string;\n}\n\nexport interface SequenceInfo {\n  width: number;\n  height: number;\n  frameCount: number;\n  alphaStartX: number;\n  alphaStartY: number;\n}\n\nexport interface Mp4Info {\n  width: number;\n  height: number;\n}\n\nexport class PAGGenerator {\n  public static generatorMP4(videoData: VideoData): Mp4Data {\n    const nalus = H264Parser.getNaluFromSequence(videoData.sequence);\n    const frames = H264Parser.getH264Frames(nalus);\n    const remuxer = H264Remuxer.remux(frames, videoData);\n    return {\n      matrix: videoData.matrix,\n      sequenceInfo: {\n        width: videoData.sequence.width,\n        height: videoData.sequence.height,\n        frameCount: videoData.sequence.frameCount,\n        alphaStartX: videoData.sequence.alphaStartX,\n        alphaStartY: videoData.sequence.alphaStartY,\n      },\n      mp4Info: {\n        width: remuxer.mp4track.width,\n        height: remuxer.mp4track.height,\n      },\n      data: remuxer.convertMp4(),\n    };\n  }\n}\n","export enum RenderingMode {\n  Canvas = 'Canvas',\n  WebGL = 'WebGL',\n}\n\nexport enum EventName {\n  beforeFlush = 'beforeFlush',\n  afterFlush = 'afterFlush',\n  onAnimationStart = 'onAnimationStart',\n  onAnimationEnd = 'onAnimationEnd',\n  onAnimationCancel = 'onAnimationCancel',\n  onAnimationRepeat = 'onAnimationRepeat',\n}\n\nexport enum ScaleMode {\n  None = 'None',\n  /**\n   * 拉伸内容到适应画布\n   */\n  Stretch = 'Stretch',\n  /**\n   * 根据原始比例缩放内容\n   */\n  LetterBox = 'LetterBox',\n  /**\n   * 根据原始比例被缩放适应，一个轴会被裁剪\n   */\n  Zoom = 'Zoom',\n}\n","import { PAGCodec } from './pag-codec';\nimport { Composition } from './base/composition';\nimport { ImageBytes } from './base/image-bytes';\nimport { request } from './base/utils/http-request';\nimport { Log } from './base/utils/log';\nimport { LayerType } from './base/layer';\nimport { VectorComposition } from './base/vector-composition';\nimport { ByteArray } from './codec/utils/byte-array';\nimport { CompositionType } from './codec/types';\nimport { TimeRange } from './base/time-range';\nimport { PreComposeLayer } from './base/pre-compose-layer';\nimport { VideoData } from './file/video-data';\nimport { isPAGFile } from './file/utils';\nimport { ErrorCode } from './base/utils/error-map';\nimport { Mp4Data, PAGGenerator } from './pag-generator';\n\nexport class PAGFile {\n  public static async loadFile(url: string | File): Promise<Mp4Data> {\n    let file: File;\n    if (typeof url === 'string' && url !== '') {\n      file = await this.loadFileByXHR(url);\n    } else if (url instanceof File && isPAGFile(url)) {\n      file = url;\n    } else {\n      Log.error(ErrorCode.InputError);\n    }\n    const pagFile = await this.readFileAsPAGFile(file);\n    const videoData = PAGFile.pagFile2videoData(pagFile);\n    return PAGGenerator.generatorMP4(videoData);\n  }\n\n  public static loadFileByXHR(url: string): Promise<File> {\n    return new Promise((resolve) => {\n      request({\n        url,\n        method: 'GET',\n        responseType: 'blob',\n        success: (response: Blob) => {\n          if (!response) {\n            Log.error(ErrorCode.LoadFileNotResponse);\n          }\n          const file = new window.File([response], url.replace(/(.*\\/)*([^.]+)/i, '$2'));\n          resolve(file);\n        },\n        error: () => {\n          Log.error(ErrorCode.LoadFileByXhrError);\n        },\n      });\n    });\n  }\n\n  public static readFileAsPAGFile(file: File): Promise<PAGFile> {\n    return new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = () => {\n        const dataBuffer: ArrayBuffer = reader.result as ArrayBuffer;\n        const byteArray = new ByteArray(dataBuffer, true);\n        const { compositions, images, tagLevel } = PAGCodec.decode(byteArray);\n        const pagFile = new PAGFile(compositions, images);\n        pagFile.tagLevel = tagLevel;\n        resolve(pagFile);\n      };\n      reader.onerror = () => {\n        Log.error(ErrorCode.ReadPagFileError);\n      };\n      reader.readAsArrayBuffer(file);\n    });\n  }\n\n  public static pagFile2videoData(file: PAGFile) {\n    return VideoData.create(file);\n  }\n  public tagLevel = 1;\n  public mainComposition: Composition;\n  public compositions: Array<Composition> = [];\n  public numLayers = 0;\n  public images: Array<ImageBytes> = [];\n  public duration: number;\n  public implDuration: number;\n  public scaledTimeRange: TimeRange = { start: 0, end: 0 };\n  public rootLayer: PreComposeLayer;\n\n  constructor(compositions: Array<Composition>, images: Array<ImageBytes>) {\n    this.mainComposition = compositions[compositions.length - 1];\n    this.scaledTimeRange.start = 0;\n    this.scaledTimeRange.end = this.mainComposition.duration;\n    this.compositions = compositions;\n    this.images = images;\n    this.duration = this.mainComposition.duration;\n    this.implDuration = (this.mainComposition.duration * 1000) / this.mainComposition.frameRate;\n    for (const composition of compositions) {\n      if (composition.type() !== CompositionType.Vector) {\n        this.numLayers += 1;\n        continue;\n      }\n      for (const layer of (composition as VectorComposition).layers) {\n        if (layer.type() === LayerType.PreCompose) {\n          continue;\n        }\n        this.numLayers += 1;\n      }\n    }\n  }\n}\n","export const isPAGFile = (file: File) => /(?:pag)$/.test(file.name);\n","interface RequestOption {\n  url: string;\n  method?: string;\n  data?: object;\n  responseType?: XMLHttpRequestResponseType;\n  success?: (any) => void;\n  error?: (any) => void;\n}\n\nexport function request(option: RequestOption) {\n  if (String(option) !== '[object Object]') return undefined;\n  const params = Object.assign(option);\n  params.method = option.method ? option.method.toUpperCase() : 'GET';\n  params.data = option.data || {};\n  let data = '';\n  const formData = Object.keys(params.data).map((key) => `${key}=${params.data[key]}`);\n  data = formData.join('&');\n\n  if (params.method === 'GET' && formData.length > 0) {\n    params.url += location.search.length === 0 ? ''.concat('?', data) : ''.concat('&', data);\n  }\n\n  const xhr = new XMLHttpRequest();\n\n  xhr.responseType = params.responseType;\n  xhr.onreadystatechange = () => {\n    if (xhr.readyState === 4) {\n      if (xhr.status === 200) {\n        if (params.success && typeof params.success === 'function') {\n          params.success(xhr.response);\n        }\n      } else {\n        if (params.error && typeof params.error === 'function') {\n          params.error(xhr.onerror);\n        }\n      }\n    }\n  };\n  xhr.open(params.method, params.url, true);\n  if (params.method === 'POST') {\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n  }\n  xhr.send(params.method === 'POST' ? data : undefined);\n}\n","import { ByteArray } from './codec/utils/byte-array';\nimport { Log } from './base/utils/log';\nimport { readTags } from './codec/tags/tag-header';\nimport { readTagsOfFile } from './codec/tags/file-tags';\nimport { Composition } from './base/composition';\nimport { ImageBytes } from './base/image-bytes';\nimport { CompositionType, TagCode } from './codec/types';\nimport { VectorComposition } from './base/vector-composition';\nimport { LayerType } from './base/layer';\nimport { PreComposeLayer } from './base/pre-compose-layer';\nimport { ErrorCode } from './base/utils/error-map';\n\nexport const verifyAndMake = (compositions: Array<Composition>, images: Array<ImageBytes>) => {\n  let success: boolean = compositions.length > 0;\n  for (const composition of compositions) {\n    if (!composition || !composition.verify()) {\n      success = false;\n      break;\n    }\n  }\n\n  for (const imagBytes of images) {\n    if (!imagBytes || !imagBytes.verify()) {\n      success = false;\n      break;\n    }\n  }\n\n  if (!success) {\n    compositions = undefined;\n    images = undefined;\n    return undefined;\n  }\n  return { compositions, images };\n};\n\n/**\n * 将Layer里面的compositionID标识换成真正的Composition\n */\nexport function installReference(compositions: Array<Composition>) {\n  if (!compositions || compositions.length === 0) {\n    return;\n  }\n  const compositionMap = new Map();\n  for (const composition of compositions) {\n    if (!composition) {\n      continue;\n    }\n    compositionMap.set(composition.id, composition);\n  }\n  for (const item of compositions) {\n    if (!item) {\n      continue;\n    }\n    if (item.type() === CompositionType.Vector) {\n      const vectorItem = item as VectorComposition;\n      if (vectorItem.layers !== undefined && vectorItem.layers.length > 0) {\n        for (const layer of vectorItem.layers) {\n          layer.containingComposition = vectorItem;\n          const preComposeLayer = layer as PreComposeLayer;\n          if (preComposeLayer.type() === LayerType.PreCompose && preComposeLayer.composition !== undefined) {\n            const ID = preComposeLayer.composition.id;\n            const result = compositionMap.get(ID);\n            if (result !== undefined) {\n              preComposeLayer.composition = result;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class PAGCodec {\n  public static maxSupportedTagLevel(): number {\n    return TagCode.Count - 1;\n  }\n\n  /**\n   * 从特殊的字节流中解码出一个 PAG 文件\n   */\n  public static decode(byteArray: ByteArray) {\n    if (!byteArray) Log.error(ErrorCode.NotByteArray);\n    const bodyByteArray: ByteArray = this.readBodyBytes(byteArray);\n    const { context } = bodyByteArray;\n    readTags(bodyByteArray, context, readTagsOfFile);\n    installReference(context.compositions);\n    const { compositions, images } = verifyAndMake(context.releaseCompositions(), context.releaseImages());\n    return { compositions, images, tagLevel: context.tagLevel };\n  }\n\n  public static readBodyBytes(byteArray: ByteArray): ByteArray {\n    if (byteArray.length < 11) Log.error(ErrorCode.PagFileLengthErrorTooShort);\n\n    const P: number = byteArray.readInt8();\n    const A: number = byteArray.readInt8();\n    const G: number = byteArray.readInt8();\n    if (P !== 80 || A !== 65 || G !== 71) {\n      Log.error(ErrorCode.InvalidPagFileHeader);\n    }\n    byteArray.readInt8(); // version\n    byteArray.readUint32(); // bodyLength\n    byteArray.readInt8(); // compression\n    return byteArray.readBytes();\n  }\n}\n","import { Log } from '../base/utils/log';\nimport { Mp4Data } from '../pag-generator';\nimport { AlphaVideoAttributes } from '../pag-view';\n\nexport const detectWebGLContext = () => {\n  const canvas: HTMLCanvasElement = document.createElement('canvas');\n  const context3D: RenderingContext | null = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n  return !!context3D;\n};\n\nexport const createProgram = (\n  context3D: WebGLRenderingContext,\n  vertexShaderSource: string,\n  fragmentShaderSource: string,\n) => {\n  const program = context3D.createProgram();\n\n  const vshader = createShader(context3D, vertexShaderSource, context3D.VERTEX_SHADER);\n  const fshader = createShader(context3D, fragmentShaderSource, context3D.FRAGMENT_SHADER);\n  context3D.attachShader(program, vshader);\n  // gl.deleteShader(vshader);\n  context3D.attachShader(program, fshader);\n  // gl.deleteShader(fshader);\n  context3D.linkProgram(program);\n\n  const programMessage = context3D.getProgramInfoLog(program);\n  if (programMessage) Log.log(programMessage);\n  const vshaderMessage = context3D.getShaderInfoLog(vshader);\n  if (vshaderMessage) Log.log(vshaderMessage);\n  const fshaderMessage = context3D.getShaderInfoLog(fshader);\n  if (fshaderMessage) Log.log(fshaderMessage);\n\n  return program;\n};\n\nconst createShader = (context3D: WebGLRenderingContext, source: string, type: GLenum) => {\n  const shader = context3D.createShader(type);\n  context3D.shaderSource(shader, source);\n  context3D.compileShader(shader);\n  return shader;\n};\n\nexport const getShaderSourceFromString = (str: string) => str.replace(/^\\s+|\\s+$/g, '');\n\nexport const getVideoAttributes = (mp4Data: Mp4Data) => {\n  const attribute: AlphaVideoAttributes = {\n    width: 0,\n    height: 0,\n    videoWidth: 0,\n    videoHeight: 0,\n    hasAlpha: false,\n    alphaStartX: 0,\n    alphaStartY: 0,\n    sequenceWidth: 0,\n    sequenceHeight: 0,\n    sequenceScale: { width: 0, height: 0 },\n    position: { x: 0, y: 0 },\n    mp4Width: 0,\n    mp4Height: 0,\n  };\n  attribute.width = mp4Data.matrix.width;\n  attribute.height = mp4Data.matrix.height;\n  attribute.videoWidth = mp4Data.matrix.videoWidth;\n  attribute.videoHeight = mp4Data.matrix.videoHeight;\n  attribute.hasAlpha = mp4Data.matrix.hasAlpha;\n  if (attribute.hasAlpha) {\n    attribute.alphaStartX = mp4Data.sequenceInfo.alphaStartX;\n    attribute.alphaStartY = mp4Data.sequenceInfo.alphaStartY;\n  }\n  attribute.sequenceWidth = mp4Data.sequenceInfo.width;\n  attribute.sequenceHeight = mp4Data.sequenceInfo.height;\n  attribute.sequenceScale = {\n    width: attribute.videoWidth / attribute.sequenceWidth,\n    height: attribute.videoHeight / attribute.sequenceHeight,\n  };\n  attribute.position = {\n    x: mp4Data.matrix.transform.position.value.x - mp4Data.matrix.transform.anchorPoint.value.x,\n    y: mp4Data.matrix.transform.position.value.y - mp4Data.matrix.transform.anchorPoint.value.y,\n  };\n  return attribute;\n};\n","export const VERTEX_2D_SHADER = `\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      \n      uniform vec2 u_resolution;\n      uniform vec2 u_scale;\n      \n      varying vec2 v_texCoord;\n    \n      \n      void main() {\n         vec2 scaledPosition = a_position * u_scale;\n\n         // convert the rectangle from pixels to 0.0 to 1.0\n         vec2 zeroToOne = scaledPosition / u_resolution;\n      \n         // convert from 0->1 to 0->2\n         vec2 zeroToTwo = zeroToOne * 2.0;\n      \n         // convert from 0->2 to -1->+1 (clipspace)\n         vec2 clipSpace = zeroToTwo - 1.0;\n      \n         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n      \n         // pass the texCoord to the fragment shader\n         // The GPU will interpolate this value between points.\n         v_texCoord = a_texCoord;\n      }\n        `;\n\nexport const FRAGMENT_2D_SHADER = `\n      precision mediump float;\n\n      // our texture\n      uniform sampler2D u_image;\n      \n      // the texCoords passed in from the vertex shader.\n      varying vec2 v_texCoord;\n      \n      void main() {\n         gl_FragColor = texture2D(u_image, v_texCoord);\n      }\n         `;\nexport const FRAGMENT_2D_SHADER_TRANSPARENT = `\n      precision mediump float;\n      // our texture\n      uniform sampler2D u_image;\n      \n      // the texCoords passed in from the vertex shader.\n      varying vec2 v_texCoord;\n      uniform vec2 v_alphaStart;\n      \n      void main() {\n         vec4 color = texture2D(u_image, v_texCoord);\n         vec4 alpha = texture2D(u_image, vec2(v_texCoord.x + v_alphaStart.x, v_texCoord.y + v_alphaStart.y));\n         gl_FragColor = vec4(color.rgb * alpha.r, alpha.r);\n      }     \n         `;\n","export type Listener = (...payload: any) => void;\n\ninterface ListenersMap {\n  [propName: string]: Listener[];\n}\n\nexport class EventManager {\n  private listenersMap: ListenersMap;\n\n  constructor() {\n    this.listenersMap = {};\n  }\n\n  on(evnetName: string, linstener: Listener) {\n    if (this.listenersMap[evnetName] === undefined) {\n      this.listenersMap[evnetName] = [];\n    }\n    this.listenersMap[evnetName].push(linstener);\n    return;\n  }\n\n  off(evnetName: string, linstener?: Listener) {\n    const listenerList: Listener[] = this.listenersMap[evnetName];\n    if (listenerList === undefined) return;\n    if (linstener === undefined) {\n      delete this.listenersMap[evnetName];\n      return;\n    }\n    const index = listenerList.findIndex((fn: Listener) => fn === linstener);\n    listenerList.splice(index, 1);\n    return;\n  }\n\n  emit(evnetName: string, ...payload: any): boolean {\n    const listenerList: Listener[] = this.listenersMap[evnetName];\n    if (listenerList === undefined || listenerList.length < 1) return false;\n    for (const listener of listenerList) {\n      listener(...payload);\n    }\n    return true;\n  }\n}\n","import { RenderingMode, EventName, ScaleMode } from './view/types';\nimport { detectWebGLContext, createProgram, getShaderSourceFromString, getVideoAttributes } from './view/utils';\nimport { VERTEX_2D_SHADER, FRAGMENT_2D_SHADER, FRAGMENT_2D_SHADER_TRANSPARENT } from './view/shader';\nimport { Log } from './base/utils/log';\nimport { ErrorCode } from './base/utils/error-map';\nimport { Mp4Data } from './pag-generator';\nimport { EventManager, Listener } from './base/utils/event-manager';\n\ndeclare global {\n  interface Window {\n    WebKitMediaSource: any;\n  }\n}\n\nexport interface RenderOptions {\n  renderingMode?: RenderingMode;\n  scaleMode?: ScaleMode;\n  /**\n   * 设置动画重复的次数。默认值为 1，只播放一次。如为 0 动画则无限播放。\n   */\n  repeatCount?: number;\n  /**\n   * 关闭 dpi 缩放修正。默认开启\n   */\n  disableHidpi?: boolean;\n}\n\nexport interface AlphaVideoAttributes {\n  width: number; // PAG画布宽度\n  height: number; // PAG画布高度\n  videoWidth: number; // VideoComposition宽度\n  videoHeight: number; // VideoComposition高度\n  hasAlpha: boolean; // 是否有Alpha通道\n  alphaStartX: number; // Alpha通道 X轴坐标\n  alphaStartY: number; // Alpha通道 Y轴坐标\n  sequenceWidth: number; // Sequence宽度\n  sequenceHeight: number; // Sequence高度\n  sequenceScale: { width: number; height: number }; // Sequence需要缩放大小\n  position: { x: number; y: number }; // VideoComposition在PAG画布上的坐标\n  mp4Width: number; // Mp4 video宽度\n  mp4Height: number; // Mp4 video高度\n}\n\nexport class PAGView {\n  /**\n   * 渲染类型的枚举\n   */\n  public static renderingMode = RenderingMode;\n  /**\n   * 缩放模式的枚举\n   */\n  public static scaleMode = ScaleMode;\n\n  /**\n   * 创建一个 PAGView 对象\n   * @param mp4Data mp4数据\n   * @param canvas 渲染画板\n   * @param options 渲染选项\n   * @returns PAGView 对象\n   */\n  public static create(mp4Data: Mp4Data, canvas: HTMLCanvasElement, options: RenderOptions): PAGView {\n    const pagView = new PAGView(mp4Data, canvas, options);\n    pagView.supportWebGL = detectWebGLContext();\n    pagView.videoAttributes = getVideoAttributes(pagView.mp4Data);\n    pagView.eventManager = new EventManager();\n    pagView.videoEl = document.createElement('video');\n    pagView.videoEl.style.display = 'none';\n    pagView.videoEl.muted = true;\n    pagView.videoEl.playsInline = true;\n    const blob = new Blob([mp4Data.data], { type: 'video/mp4' });\n    pagView.videoEl.src = URL.createObjectURL(blob);\n    if (!!mp4Data.mp4Info.width) {\n      pagView.videoAttributes.mp4Width = mp4Data.mp4Info.width;\n    }\n    if (!!mp4Data.mp4Info.height) {\n      pagView.videoAttributes.mp4Height = mp4Data.mp4Info.height;\n    }\n\n    pagView.videoEl.addEventListener('play', () => {\n      pagView.flushLoop(pagView, pagView.videoEl);\n    });\n    pagView.videoEl.addEventListener('pause', () => {\n      pagView.clearRenderTimer();\n    });\n    pagView.videoEl.addEventListener('ended', () => {\n      // 无限循环\n      if (pagView.repeatCount < 0) {\n        pagView.videoEl.play();\n        pagView.eventManager.emit('onAnimationRepeat');\n        return;\n      }\n      // 循环结束\n      if (pagView.repeatCount === 0) {\n        pagView.videoEl.currentTime = 0;\n        pagView.clearRenderTimer();\n        pagView.clearRender();\n        pagView.playing = false;\n        pagView.eventManager.emit('onAnimationEnd');\n        return;\n      }\n      // 次数循环\n      pagView.repeatCount -= 1;\n      pagView.videoEl.play();\n      pagView.eventManager.emit('onAnimationRepeat');\n    });\n\n    pagView.setRenderingMode(pagView.renderingMode);\n    pagView.setScaleMode(options.scaleMode);\n    if (pagView.renderingMode === RenderingMode.WebGL) pagView.loadWithWebGL();\n    if (pagView.renderingMode === RenderingMode.Canvas) pagView.loadWithCanvas();\n    return pagView;\n  }\n\n  private canvas: HTMLCanvasElement;\n  private supportWebGL: boolean;\n  private videoEl: HTMLVideoElement;\n  private videoAttributes: AlphaVideoAttributes;\n  private mp4Data: Mp4Data;\n  private renderingMode: RenderingMode;\n  private context2D: CanvasRenderingContext2D;\n  private gl: WebGLRenderingContext;\n  private program: WebGLProgram;\n  private positionLocation = 0;\n  private texcoordLocation = 0;\n  private alphaStartLocation: WebGLUniformLocation;\n  private scaleLocation: WebGLUniformLocation;\n  private positionBuffer: WebGLBuffer;\n  private texcoordBuffer: WebGLBuffer;\n  private renderTimer: number | null = null;\n  private renderCanvas2D: HTMLCanvasElement;\n  private renderCanvas2DContext: CanvasRenderingContext2D;\n  private playing = false;\n  private destroyed = false;\n  private repeatCount = 0; // 设置动画重复的次数。默认值为 0，只播放一次。如为 -1 动画则无限播放。\n  private eventManager: EventManager;\n  private viewScaleMode: ScaleMode;\n  private viewportSize = { x: 0, y: 0, width: 0, height: 0, scaleX: 1, scaleY: 1 }; // viewport尺寸 WebGL坐标轴轴心在左下角|Canvas2D坐标轴轴心在左上角\n\n  constructor(mp4Data: Mp4Data, canvas: HTMLCanvasElement, options: RenderOptions) {\n    this.canvas = canvas;\n    if (!options.disableHidpi) {\n      canvas.style.width = `${canvas.width}px`;\n      canvas.style.height = `${canvas.height}px`;\n      canvas.width = canvas.width * window.devicePixelRatio;\n      canvas.height = canvas.height * window.devicePixelRatio;\n    }\n    this.mp4Data = mp4Data;\n    this.renderingMode = options.renderingMode || RenderingMode.WebGL;\n    if (options.repeatCount !== undefined) {\n      this.repeatCount = options.repeatCount < 0 ? -1 : options.repeatCount - 1;\n    }\n  }\n\n  /**\n   * 开始播放\n   */\n  public play() {\n    if (this.destroyed) Log.error(ErrorCode.PagDestroyed);\n    if (!!this.playing) return;\n    this.videoEl.play();\n    this.playing = true;\n    this.eventManager.emit('onAnimationStart');\n  }\n  /**\n   * 暂停播放\n   */\n  public pause() {\n    if (this.destroyed) Log.error(ErrorCode.PagDestroyed);\n    if (!this.playing) return;\n    this.videoEl.pause();\n    this.playing = false;\n    this.eventManager.emit('onAnimationCancel');\n  }\n  /**\n   * 停止播放\n   */\n  public stop() {\n    if (this.destroyed) Log.error(ErrorCode.PagDestroyed);\n    this.videoEl.pause();\n    this.videoEl.currentTime = 0;\n    this.clearRender();\n    this.playing = false;\n    this.eventManager.emit('onAnimationCancel');\n  }\n  /**\n   * 销毁播放实例\n   */\n  public destroy() {\n    if (this.destroyed) return;\n    this.stop();\n    this.canvas = null;\n    this.videoEl = null;\n    this.destroyed = true;\n  }\n  /**\n   * 是否播放中\n   */\n  public isPlaying() {\n    return this.playing;\n  }\n  /**\n   * 是否已经销毁\n   */\n  public isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * 动画持续时间\n   */\n  public duration() {\n    return this.videoEl.duration;\n  }\n  /**\n   * 设置动画重复的次数。默认值为 1，只播放一次。如为 0 动画则无限播放。\n   */\n  public setRepeatCount(repeatCount = 1) {\n    this.repeatCount = repeatCount < 0 ? -1 : repeatCount - 1;\n  }\n  /**\n   * 返回当前播放进度位置，取值范围为 0.0 到 1.0。\n   */\n  public getProgress() {\n    return Math.round((this.videoEl.currentTime / this.videoEl.duration) * 100) / 100;\n  }\n  /**\n   * 设置播放进度位置，取值范围为 0.0 到 1.0。\n   */\n  public setProgress(progress: number) {\n    if (this.destroyed) Log.error(ErrorCode.PagDestroyed);\n    if (progress < 0 || progress > 1) Log.error(ErrorCode.InvalidPercentage);\n    if (this.playing) this.pause();\n    this.videoEl.currentTime = progress * this.videoEl.duration;\n    return new Promise((resolve) => {\n      const timeupdateCallback = () => {\n        this.flush(this.videoEl);\n        this.videoEl.removeEventListener('timeupdate', timeupdateCallback);\n        resolve(true);\n      };\n      this.videoEl.addEventListener('timeupdate', timeupdateCallback);\n    });\n  }\n  /**\n   * 渲染当前进度画面\n   */\n  public flush(videoEl: HTMLVideoElement) {\n    this.eventManager.emit(EventName.beforeFlush);\n    if (this.renderingMode === RenderingMode.WebGL) {\n      this.renderWithWebGL(videoEl);\n    } else {\n      this.renderWithCanvas(videoEl);\n    }\n    this.eventManager.emit(EventName.afterFlush);\n  }\n  /**\n   * 增加事件监听\n   */\n  public addListener(eventName: string, listener: Listener) {\n    return this.eventManager.on(eventName, listener);\n  }\n  /**\n   * 移除事件监听\n   */\n  public removeListener(eventName: string, listener?: Listener) {\n    return this.eventManager.off(eventName, listener);\n  }\n  /**\n   * 返回当前缩放模式\n   */\n  public scaleMode() {\n    return this.viewScaleMode;\n  }\n  /**\n   * 指定缩放内容的模式\n   */\n  public setScaleMode(scaleMode: ScaleMode = ScaleMode.LetterBox) {\n    this.viewScaleMode = scaleMode;\n    switch (scaleMode) {\n      case ScaleMode.None:\n        this.viewportSize = {\n          x: this.videoAttributes.position.x,\n          y:\n            this.renderingMode === RenderingMode.WebGL\n              ? this.gl.canvas.height - this.videoAttributes.position.y - this.videoAttributes.videoHeight\n              : this.videoAttributes.position.y,\n          width: this.videoAttributes.videoWidth,\n          height: this.videoAttributes.videoHeight,\n          scaleX: 1,\n          scaleY: 1,\n        };\n        break;\n      case ScaleMode.Stretch:\n        {\n          const scaleX = this.canvas.width / this.videoAttributes.width;\n          const scaleY = this.canvas.height / this.videoAttributes.height;\n          this.viewportSize = {\n            x: this.videoAttributes.position.x * scaleX,\n            y:\n              this.renderingMode === RenderingMode.WebGL\n                ? this.canvas.height -\n                  this.videoAttributes.position.y * scaleY -\n                  this.videoAttributes.videoHeight * scaleY\n                : this.videoAttributes.position.y * scaleY,\n            width: this.videoAttributes.videoWidth * scaleX,\n            height: this.videoAttributes.videoHeight * scaleY,\n            scaleX,\n            scaleY,\n          };\n        }\n        break;\n      case ScaleMode.LetterBox:\n        {\n          const scaleX = this.canvas.width / this.videoAttributes.width;\n          const scaleY = this.canvas.height / this.videoAttributes.height;\n          const scale = Math.min(scaleX, scaleY);\n          this.viewportSize = {\n            x: (this.canvas.width - this.videoAttributes.width * scale) / 2 + this.videoAttributes.position.x * scale,\n            y:\n              this.renderingMode === RenderingMode.WebGL\n                ? this.canvas.height -\n                  (this.canvas.height - this.videoAttributes.height * scale) / 2 -\n                  this.videoAttributes.position.y * scale -\n                  this.videoAttributes.videoHeight * scale\n                : (this.canvas.height - this.videoAttributes.height * scale) / 2 +\n                  this.videoAttributes.position.y * scale,\n            width: this.videoAttributes.videoWidth * scale,\n            height: this.videoAttributes.videoHeight * scale,\n            scaleX: scale,\n            scaleY: scale,\n          };\n        }\n        break;\n      case ScaleMode.Zoom:\n        {\n          const scaleX = this.canvas.width / this.videoAttributes.width;\n          const scaleY = this.canvas.height / this.videoAttributes.height;\n          const scale = Math.max(scaleX, scaleY);\n          this.viewportSize = {\n            x: (this.canvas.width - this.videoAttributes.width * scale) / 2 + this.videoAttributes.position.x * scale,\n            y:\n              this.renderingMode === RenderingMode.WebGL\n                ? this.canvas.height -\n                  (this.canvas.height - this.videoAttributes.height * scale) / 2 -\n                  this.videoAttributes.position.y * scale -\n                  this.videoAttributes.videoHeight * scale\n                : (this.canvas.height - this.videoAttributes.height * scale) / 2 +\n                  this.videoAttributes.position.y * scale,\n            width: this.videoAttributes.videoWidth * scale,\n            height: this.videoAttributes.videoHeight * scale,\n            scaleX: scale,\n            scaleY: scale,\n          };\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private clearRender() {\n    if (this.destroyed) Log.error(ErrorCode.PagDestroyed);\n\n    if (this.renderingMode === RenderingMode.WebGL) {\n      this.clearRenderWithWebGL();\n    } else {\n      this.clearRenderWithCanvas();\n    }\n  }\n\n  private setRenderingMode(renderingMode: RenderingMode) {\n    if (renderingMode === RenderingMode.WebGL) {\n      if (this.supportWebGL === false) {\n        this.renderingMode = RenderingMode.Canvas;\n        this.setRenderingMode(RenderingMode.Canvas);\n        return;\n      }\n      if (!this.gl) {\n        this.gl = this.canvas.getContext('webgl', {});\n      }\n      if (!this.gl) {\n        this.renderingMode = RenderingMode.Canvas;\n        this.setRenderingMode(RenderingMode.Canvas);\n      } else {\n        if (!!this.videoAttributes.hasAlpha) {\n          this.program = createProgram(\n            this.gl,\n            getShaderSourceFromString(VERTEX_2D_SHADER),\n            getShaderSourceFromString(FRAGMENT_2D_SHADER_TRANSPARENT),\n          );\n        } else {\n          this.program = createProgram(\n            this.gl,\n            getShaderSourceFromString(VERTEX_2D_SHADER),\n            getShaderSourceFromString(FRAGMENT_2D_SHADER),\n          );\n        }\n      }\n    } else {\n      this.context2D = this.canvas.getContext('2d');\n    }\n  }\n\n  private loadWithWebGL() {\n    // look up where the vertex data needs to go.\n    this.positionLocation = this.gl.getAttribLocation(this.program, 'a_position');\n    if (this.positionLocation === -1) throw new Error('unable to get attribute location for a_position');\n\n    this.scaleLocation = this.gl.getUniformLocation(this.program, 'u_scale');\n    if (this.scaleLocation === -1) throw new Error('unable to get attribute location for u_scale');\n\n    this.texcoordLocation = this.gl.getAttribLocation(this.program, 'a_texCoord');\n    if (this.texcoordLocation === -1) throw new Error('unable to get attribute location for a_texCoord');\n\n    this.alphaStartLocation = this.gl.getUniformLocation(this.program, 'v_alphaStart');\n    if (this.alphaStartLocation === -1) throw new Error('unable to get attribute location for v_alphaStart');\n\n    // Create a buffer to put three 2d clip space points in\n    this.positionBuffer = this.gl.createBuffer();\n\n    // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n    // Set a rectangle the same size as the image.\n    this.setRectangle(this.gl, 0, 0, this.videoAttributes.mp4Width, this.videoAttributes.mp4Height);\n\n    // provide texture coordinates for the rectangle.\n    this.texcoordBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);\n\n    // Create a texture.\n    const texture: WebGLTexture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n\n    // Set the parameters so we can render any size video.\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array([\n        0 + 0.5 / this.videoAttributes.mp4Width,\n        0.0 + 0.5 / this.videoAttributes.mp4Height,\n        1.0 - 0.5 / this.videoAttributes.mp4Width,\n        0.0 + 0.5 / this.videoAttributes.mp4Height,\n        0.0 + 0.5 / this.videoAttributes.mp4Width,\n        1.0 - 0.5 / this.videoAttributes.mp4Height,\n        0.0 + 0.5 / this.videoAttributes.mp4Width,\n        1.0 - 0.5 / this.videoAttributes.mp4Height,\n        1.0 - 0.5 / this.videoAttributes.mp4Width,\n        0.0 + 0.5 / this.videoAttributes.mp4Height,\n        1.0 - 0.5 / this.videoAttributes.mp4Width,\n        1.0 - 0.5 / this.videoAttributes.mp4Height,\n      ]),\n      this.gl.STATIC_DRAW,\n    );\n  }\n\n  private loadWithCanvas() {\n    this.renderCanvas2D = document.createElement('canvas');\n    this.renderCanvas2D.width =\n      this.videoAttributes.mp4Width * this.videoAttributes.sequenceScale.width * this.viewportSize.scaleX;\n    this.renderCanvas2D.height =\n      this.videoAttributes.mp4Height * this.videoAttributes.sequenceScale.height * this.viewportSize.scaleY;\n    this.renderCanvas2DContext = this.renderCanvas2D.getContext('2d');\n  }\n\n  private setRectangle(gl: WebGLRenderingContext, x: number, y: number, width: number, height: number) {\n    const x1: number = x;\n    const x2: number = x + width;\n    const y1: number = y;\n    const y2: number = y + height;\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);\n  }\n\n  private flushLoop(pagView: PAGView, videoEl: HTMLVideoElement) {\n    pagView.flush(videoEl);\n    this.renderTimer = window.requestAnimationFrame(() => {\n      this.flushLoop(pagView, videoEl);\n    });\n  }\n\n  private renderWithWebGL(videoEl: HTMLVideoElement) {\n    // Upload the video into the texture.\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, videoEl);\n\n    // lookup uniforms\n    const resolutionLocation = this.gl.getUniformLocation(this.program, 'u_resolution');\n\n    // Tell WebGL how to convert from clip space to pixels\n    this.gl.viewport(this.viewportSize.x, this.viewportSize.y, this.viewportSize.width, this.viewportSize.height);\n\n    // Clear the canvas\n    this.gl.clearColor(0, 0, 0, 0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Tell it to use our program (pair of shaders)\n    this.gl.useProgram(this.program);\n\n    // Turn on the position attribute\n    this.gl.enableVertexAttribArray(this.positionLocation);\n\n    // Bind the position buffer\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n\n    // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n    const size = 2; // 2 components per iteration\n    const type: number = this.gl.FLOAT; // the data is 32bit floats\n    const normalize = false; // don't normalize the data\n    const stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\n    const offset = 0; // start at the beginning of the buffer\n    this.gl.vertexAttribPointer(this.positionLocation, size, type, normalize, stride, offset);\n\n    // Turn on the teccord attribute\n    this.gl.enableVertexAttribArray(this.texcoordLocation);\n\n    // Bind the position buffer.\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.texcoordBuffer);\n\n    this.gl.vertexAttribPointer(this.texcoordLocation, size, type, normalize, stride, offset);\n\n    // set the resolution\n    this.gl.uniform2f(resolutionLocation, this.videoAttributes.videoWidth, this.videoAttributes.videoHeight);\n\n    if (!!this.videoAttributes.hasAlpha) {\n      this.gl.uniform2f(\n        this.alphaStartLocation,\n        this.videoAttributes.alphaStartX / this.videoAttributes.mp4Width,\n        this.videoAttributes.alphaStartY / this.videoAttributes.mp4Height,\n      );\n    }\n\n    this.gl.uniform2f(\n      this.scaleLocation,\n      this.videoAttributes.sequenceScale.width,\n      this.videoAttributes.sequenceScale.height,\n    );\n\n    // Draw the rectangle.\n    const primitiveType: number = this.gl.TRIANGLES;\n    const count = 6;\n    this.gl.drawArrays(primitiveType, offset, count);\n  }\n\n  private renderWithCanvas(videoEl: HTMLVideoElement) {\n    if (this.videoAttributes.videoWidth === 0 || this.videoAttributes.videoHeight === 0) {\n      return;\n    }\n    if (!!this.videoAttributes.hasAlpha) {\n      this.renderCanvas2DContext.clearRect(0, 0, this.renderCanvas2D.width, this.renderCanvas2D.height);\n      this.renderCanvas2DContext.drawImage(videoEl, 0, 0, this.renderCanvas2D.width, this.renderCanvas2D.height);\n      const frameOne = this.renderCanvas2DContext.getImageData(0, 0, this.viewportSize.width, this.viewportSize.height);\n      const frameTwo = this.renderCanvas2DContext.getImageData(\n        this.videoAttributes.alphaStartX * this.videoAttributes.sequenceScale.width * this.viewportSize.scaleX,\n        this.videoAttributes.alphaStartY * this.videoAttributes.sequenceScale.height * this.viewportSize.scaleY,\n        this.viewportSize.width,\n        this.viewportSize.height,\n      );\n      const length = frameOne.data.length / 4;\n      for (let i = 0; i < length; i++) {\n        frameOne.data[i * 4 + 3] = frameTwo.data[i * 4 + 0];\n      }\n      this.context2D.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      this.context2D.putImageData(\n        frameOne,\n        this.viewportSize.x,\n        this.viewportSize.y,\n        0,\n        0,\n        this.viewportSize.width,\n        this.viewportSize.height,\n      );\n    } else {\n      this.context2D.drawImage(\n        videoEl,\n        0,\n        0,\n        this.videoAttributes.sequenceWidth,\n        this.videoAttributes.sequenceHeight,\n        this.videoAttributes.position.x,\n        this.videoAttributes.position.y,\n        this.videoAttributes.videoWidth,\n        this.videoAttributes.videoHeight,\n      );\n    }\n  }\n\n  private clearRenderWithWebGL() {\n    this.gl.clearColor(0, 0, 0, 0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n  }\n\n  private clearRenderWithCanvas() {\n    this.context2D.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  private clearRenderTimer() {\n    if (this.renderTimer) {\n      window.cancelAnimationFrame(this.renderTimer);\n      this.renderTimer = null;\n    }\n  }\n}\n"],"names":["ErrorCode","ErrorCode2","ErrorMap","message","log","errorCode","Error","CompositionType","CompositionType2","TagCode","TagCode2","readTagHeader","byteBuffer","codeAndLength","readUint16","length","code","readUint32","context","tagLevel","byteArray","parameter","reader","header","End","tagBytes","readBytes","BlendMode","BlendMode2","PathVerb","PathVerb2","KeyframeInterpolationType","KeyframeInterpolationType2","ParagraphJustification","ParagraphJustification2","Black","red","green","blue","White","verifyFailed","verifyAndrReturn","expression","constructor","cacheID","_Composition","cacheIDCount","type","Unknown","getStaticTimeRanges","verify","this","width","height","duration","frameRate","Composition","Video","staticTimeRangeUpdated","updateStaticTimeRanges","staticTimeRanges","sequences","sequence","i","item","timeScale","timeRange","start","Math","round","end","push","range","hasImageContent","super","numerator","denominator","value","DefaultRatio","Ratio","x","y","ZERO_POINT","Point","LayerStyleType","LayerStyleType2","TrackMatteType","TrackMatteType2","LayerType","LayerType2","MaskMode","MaskMode2","Normal","excludeVaryingRanges","timeRanges","transform","timeRemap","masks","mask","effects","effect","layerStyles","layerStyle","gotoFrame","frame","containingComposition","getMaxScaleFactor","maxScale","property","scale","animatable","keyframes","scaleX","abs","startValue","scaleY","keyframe","endValue","parent","parentScale","BEZIER_PRECISION","readColor","readUint8","readTime","readEncodedUint64","readPoint","readFloat32","readCompositionAttributes","composition","readEncodeInt32","backgroundColor","frames","fileBytes","headers","data","throwException","errorMessages","releaseCompositions","compositions","slice","releaseImages","images","buffer","littleEndian","dataView","DataView","Context","byteLength","position","alignWithBytes","bitPosition","readBoolean","getInt8","positonChangend","Boolean","readChar","error","PagCodecError","String","fromCharCode","getUint8","readInt8","readInt16","getInt16","getUint16","readInt24","left","right","__pow","readUint24","readInt32","getInt32","getUint32","readInt64","readUint64","getFloat32","readDouble","getFloat64","readUTF8String","encoded","dataLength","toString","decodeURIComponent","readEncodedUint32","byte","readEncodeInt64","newBuffer","ByteArray","readUBits","numBits","bitMasks","pos","bytePosition","floor","bitLength","min","bitPositionChanged","readBits","readNumBits","readInt32List","count","Array","readUint32List","readBitBoolean","readFloatList","percision","ceil","concatUint8Arrays","arrays","totalLength","arr","result","Uint8Array","offset","set","readByteDataWithStartCode","bytes","ReadStartCodeError","ArrayBuffer","dst","dstOffset","src","srcOffset","num","dstUint8Array","srcUint8Array","setUint8","ByteData","ReadTagsOfVideoComposition","CompositionAttributes","VideoSequence","hasAlpha","videoSequence","alphaStartX","alphaStartY","sps","pps","frameCount","videoFrame","VideoFrame","isKeyframe","bytesAvailable","staticTimeRange","readVideoSequence","EffectType","EffectType2","AttributeType","AttributeType2","startTime","endTime","splice","Vector","layer","layers","_timeRanges","_time","Transform2D","anchorPoint","Property","xPosition","yPosition","rotation","opacity","Layer","PreComposeLayer","PreCompose","ranges","compositionStartTime","pop","Shape","element","contents","Solid","undefined","Hold","initialize","getValue","containsTime","time","interpolationType","Bezier","Linear","lastKeyframe","lastKeyframeIndex","readTagBlock","blockConfig","tagConfig","flags","configs","config","flag","readAttributeFlag","index","target","key","readAttribute","attributeType","defaultValue","_byteArray","_flag","_targetClass","_target","readValue","readValueList","_list","_count","dimensionality","newKeyframe","Keyframe","targetClass","exist","readProperty","readKeyframes","hasSpatial","AnimatableProperty","numFrames","readTimeAndValue","list","readTimeEase","bezierOut","bezierIn","a","b","t","getInterpolation","input","xInterpolator","Interpolator","yInterpolator","progress","xProgress","yProgress","interpolateFloat","interpolator","getProgress","BaseAttribute","SingleEaseKeyframe","valueList","SpatialProperty","values","MultiDimensionProperty","MultiDimensionPointKeyframe","numeratorValue","denominatorValue","readRatio","id","readLayerID","readBlockConfigOfLayerAttributes","tagCode","LayerAttributes","BOOLAttributeConfig","BitFlag","LayerAttributeConfig","Value","RatioAttributeConfig","TimeAttributeConfig","Uint8AttributeConfig","None","FloatAttributeConfig","SimpleProperty","FixedValue","readBlockConfigOfLayerAttributesV2","LayerAttributesV2","readBlockConfigOfTransform2D","PointAttributeConfig","MaskBlock","readTagsOfLayer","SolidColor","solidColor","CompositionReference","readTagsOfVectorComposition","LayerBlock","UnDefinedLayer","SolidLayer","ShapeLayer","readLayer","installArrayLayerReference","layerMap","Map","ID","get","hasTrackMatte","trackMatteType","trackMatteLayer","DisplacementMap","installLayerReference","maskMap","maskReferences","Fill","fillMask","Stroke","strokeEffect","path","Text","pathOption","Alpha","AlphaInverted","VectorCompositionBlock","VectorComposition","readVectorComposition","VideoCompositionBlock","VideoComposition","readVideoComposition","videoWidth","videoHeight","file","NotPagFile","videoData","VideoData","mainComposition","getVideoDataFromVideoComposition","getVideoDataFromVectorComposition","getH264Raw","NotSequence","uint8Arrays","map","concatArrayBuffers2Uint8Array","header2","getPTS","matrix","createDefaultTransform2D","sequencesCount","composition2","NotSupportMultipleSequence","videoComposition","_NALU","idr","sei","ndr","aud","nalu","nalUnitType","TYPES","payload","nalRefIdc","isVcl","sliceType","firstMbInSlice","getPayloadSize","getSize","getData","setUint32","NALU","skipBits","size","bitsAvailable","moveIndex","getBits","skipLZ","leadingZeroCount","skipUEG","skipEG","readUEG","prefix","readEG","readUByte","numberOfBytes","readUShort","readUInt","readUE","r","offsetBits","bits","nextSize","nalus","NotNalu","units","isKeyFrame","unit","parseHeader","last","concat","decoder","ExpGolomb","H264Parser","readSPS","codec","codecarray","byteOffset","h","deltaScale","lastScale","nextScale","j","numRefFramesInPicOrderCntCycle","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","sarScale","profileIdc","indexOf","chromaFormatIdc","skipScalingList","picOrderCntType","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","sarRatio","CORRECTION_UTC","decimal2HexadecimalArray","getCharCode","name","charCodeAt","avc1","avcC","btrt","ctts","dinf","dref","edts","elst","esds","ftyp","hdlr","mdat","mdhd","mdia","mfhd","minf","moof","moov","mp4a","mvex","mvhd","sdtp","stbl","stco","stsc","stsd","stsz","stts","stss","tfdt","tfhd","traf","trak","trun","trex","tkhd","vmhd","smhd","keys","types","forEach","Object","prototype","hasOwnProperty","call","_Mp4Generator","box","len","tracks","timescale","boxes","apply","sequence_number","baseMediaDecodeTime","track","hdlrTypes","Date","now","sequenceNumber","samples","dependsOn","isDependedOn","hasRedundancy","avcc","configlen","audiosamplerate","channelCount","volume","sampleDependencyTable","sampleCount","sampleDelta","implicitOffset","arraylen","array","sample","cts","isLeading","paddingValue","isNonSync","degradPrio","pts","dts","iFrames","filter","iFrame","Mp4Generator","video","audio","fullbox","NALU_BASE_TYPES","trackId","H264Remuxer","getTrackID","fragmented","fps","NotFrames","remuxer","mp4track","getImplicitOffset","readyToDecode","includes","reduce","pre","cur","parseSPS","keyFrame","convertMp4","getPayload","mp4Generator","mp4Sample","ptsList","offsetList","getNaluFromSequence","getH264Frames","remux","sequenceInfo","mp4Info","RenderingMode","RenderingMode2","EventName","EventName2","ScaleMode","ScaleMode2","scaledTimeRange","implDuration","numLayers","url","loadFileByXHR","File","test","isPAGFile","InputError","pagFile","readFileAsPAGFile","PAGFile","pagFile2videoData","PAGGenerator","generatorMP4","Promise","resolve","option","params","assign","method","toUpperCase","formData","join","location","search","xhr","XMLHttpRequest","responseType","onreadystatechange","readyState","status","success","response","onerror","open","setRequestHeader","send","LoadFileNotResponse","window","replace","LoadFileByXhrError","FileReader","onload","dataBuffer","Count","NotByteArray","bodyByteArray","readBodyBytes","readTagsOfFile","compositionMap","vectorItem","preComposeLayer","imagBytes","verifyAndMake","PagFileLengthErrorTooShort","P","A","G","InvalidPagFileHeader","decode","ReadPagFileError","readAsArrayBuffer","create","createProgram","context3D","vertexShaderSource","fragmentShaderSource","program","vshader","createShader","VERTEX_SHADER","fshader","FRAGMENT_SHADER","attachShader","linkProgram","programMessage","getProgramInfoLog","vshaderMessage","getShaderInfoLog","fshaderMessage","source","shader","shaderSource","compileShader","getShaderSourceFromString","str","VERTEX_2D_SHADER","listenersMap","on","evnetName","linstener","off","listenerList","findIndex","fn","emit","listener","mp4Data","canvas","options","disableHidpi","style","devicePixelRatio","renderingMode","WebGL","repeatCount","pagView","_PAGView","supportWebGL","document","createElement","getContext","detectWebGLContext","videoAttributes","attribute","sequenceWidth","sequenceHeight","sequenceScale","mp4Width","mp4Height","getVideoAttributes","eventManager","EventManager","videoEl","display","muted","playsInline","blob","Blob","URL","createObjectURL","addEventListener","flushLoop","clearRenderTimer","play","currentTime","clearRender","playing","setRenderingMode","setScaleMode","scaleMode","loadWithWebGL","Canvas","loadWithCanvas","destroyed","PagDestroyed","pause","stop","destroy","isPlaying","isDestroyed","setRepeatCount","setProgress","InvalidPercentage","timeupdateCallback","flush","removeEventListener","beforeFlush","renderWithWebGL","renderWithCanvas","afterFlush","addListener","eventName","removeListener","viewScaleMode","LetterBox","viewportSize","gl","Stretch","Zoom","max","clearRenderWithWebGL","clearRenderWithCanvas","context2D","positionLocation","getAttribLocation","scaleLocation","getUniformLocation","texcoordLocation","alphaStartLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","setRectangle","texcoordBuffer","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","bufferData","Float32Array","STATIC_DRAW","renderCanvas2D","renderCanvas2DContext","x1","x2","y1","y2","renderTimer","requestAnimationFrame","texImage2D","RGBA","UNSIGNED_BYTE","resolutionLocation","viewport","clearColor","clear","COLOR_BUFFER_BIT","useProgram","enableVertexAttribArray","FLOAT","vertexAttribPointer","uniform2f","primitiveType","TRIANGLES","drawArrays","clearRect","drawImage","frameOne","getImageData","frameTwo","putImageData","cancelAnimationFrame","PAGView"],"mappings":";;;;+OAAYA,EAAAC,GAAAA,EAAAD,+2BAwBCE,EAAW,GACE,yFACQ,0EACC,yDACH,kDACU,6CACN,mDACR,4DACC,iCACK,uCACR,6CACE,uCACF,6CACC,4DACJ,sEACE,uEACU,kDACN,oEACa,uEACd,6CACK,qCACJ,2DC1CTC,WACRC,IAAID,gBAEME,SACZ,IAAIC,MAAMJ,EAASG,SCPXE,EAAAC,EAOAC,EAAAC,GAPAF,EAAAD,sGAOAG,EAAAD,iBACV,GAAN,qBACa,GAAb,wCACyB,GAAzB,mDACwB,GAAxB,wCACc,GAAd,6BACa,GAAb,iCACkB,GAAlB,iCACa,GAAb,4BACa,GAAb,gCACiB,GAAjB,oCACiB,IAAjB,oCACiB,IAAjB,0CACuB,IAAvB,uCACc,IAAd,4BACY,IAAZ,2BACa,IAAb,2BACY,IAAZ,wBACU,IAAV,uBACW,IAAX,yBACY,IAAZ,qBACO,IAAP,kBACS,IAAT,0BACe,IAAf,kCACiB,IAAjB,gCACa,IAAb,2BACY,IAAZ,yBACW,IAAX,4BACe,IAAf,+BACc,IAAd,kCACkB,IAAlB,uCACmB,IAAnB,sCACiB,IAAjB,oCACiB,IAAjB,yCACsB,IAAtB,qCACa,IAAb,mCACoB,IAApB,6CACuB,IAAvB,uCACc,IAAd,6BACa,IAAb,4BACa,IAAb,8BACe,IAAf,iCACgB,IAAhB,qCACmB,IAAnB,wCACmB,IAAnB,6CACwB,IAAxB,mDACyB,IAAzB,4CACiB,IAAjB,gCACa,IAAb,6BACc,IAAd,8BACc,IAAd,wCACwB,IAAxB,0CACgB,IAAhB,sCACoB,IAApB,gDCpDWE,EAAiBC,UACtBC,EAAwBD,EAAWE,iBACrCC,GAAkC,QAAQ,QACxCC,EAAeH,GAAiB,SACvB,KAAXE,MACOH,EAAWK,cAElBL,EAAWM,QAAQC,SAAWH,MACrBE,QAAQC,SAAWH,GAEzB,CAAEA,KAAAA,EAAMD,OAAAA,eAGWK,EAAsBC,EAAcC,OAC1DC,EAASZ,EAAcS,QACpBG,EAAOP,OAASP,EAAQe,KAAK,OAC5BC,EAAWL,EAAUM,UAAUH,EAAOR,UACrCU,EAAUF,EAAOP,KAAMK,GAC1BD,EAAUF,QAAQC,SAAWM,EAASP,QAAQC,aACtCD,QAAQC,SAAWM,EAASP,QAAQC,YAEvCR,EAAcS,QCvBTO,EAAAC,EA4BAC,EAAAC,EAQAC,EAAAC,EAQAC,EAAAC,GA5CAN,EAAAD,oBACP,GAAT,sBACW,GAAX,sBACS,GAAT,qBACU,GAAV,qBACS,GAAT,qBACU,GAAV,yBACa,GAAb,2BACY,GAAZ,0BACY,GAAZ,0BACY,GAAZ,2BACa,IAAb,2BACY,IAAZ,oBACM,IAAN,qBACa,IAAb,uBACQ,IAAR,uBACa,IAAb,+BAGgB,IAAhB,mCACiB,IAAjB,qCACkB,IAAlB,+BACW,IAAX,yBACY,IAAZ,oBACM,IAAN,OAIgBG,EAAAD,sGAQAG,EAAAD,kBACT,GAAP,kBACS,GAAT,oBACS,GAAT,kBACO,GAAP,QAIgBG,EAAAD,yBACF,GAAd,gCACgB,GAAhB,iCACe,GAAf,2CAC0B,GAA1B,uDAC2B,GAA3B,yDAC4B,GAA5B,wDAC0B,GAA1B,gCCnDWE,EAAe,CAAEC,IAAK,EAAGC,MAAO,EAAGC,KAAM,GACzCC,EAAe,CAAEH,IAAK,IAAKC,MAAO,IAAKC,KAAM,KCL7CE,EAAe,OACtBpC,IAAI,uBAGGqC,EAAoBC,KAC3BA,MAGAtC,IAAI,uBACD,WCwBAuC,sBHnCc,aGgBN,cAIC,gBHnBO,iBG2BJ,wBAIaJ,eACf,OAGVK,QAAUC,EAAYC,eACfA,cAAgB,EAMvBC,cACExC,EAAgByC,QAMlBC,uBAIAC,gBACET,EAAiBU,KAAKC,MAAQ,GAAKD,KAAKE,OAAS,GAAKF,KAAKG,SAAW,GAAKH,KAAKI,UAAY,aAjDhGC,EACUV,aAAe,kBCDMU,EAA/Bb,iDACa,iBACuB,yBAEI,gCACZ,EAE1BI,cACExC,EAAgBkD,MAGlBR,6BACAE,KAAKO,8BACHA,wBAAyB,OACzBC,0BAEAR,KAAKS,iBAGPD,8BACDR,KAAKG,UAAY,MACjBH,KAAKU,UAAU9C,OAAS,EAAG,KACzB+C,EAAWX,KAAKU,UAAU,WACrBE,EAAI,EAAGA,EAAIZ,KAAKU,UAAU9C,OAAQgD,IAAK,OACxCC,EAAOb,KAAKU,UAAUE,GACxBC,EAAKT,UAAYO,EAASP,cAAsBS,SAEhDC,EAAYd,KAAKI,UAAYO,EAASP,oBACjCW,KAAaJ,EAASF,mBACrBO,MAAQC,KAAKC,MAAMH,EAAUC,MAAQF,KACrCK,IAAMF,KAAKC,MAAMH,EAAUI,IAAML,QACtCL,iBAAiBW,KAAKL,OAExB,OACCM,EAAmB,CAAEL,MAAO,EAAGG,IAAKnB,KAAKG,SAAW,QACrDM,iBAAiBW,KAAKC,IAIxBC,yBACE,EAGFvB,aACAwB,MAAMxB,UAAYC,KAAKU,UAAU9C,QAAU,cAEvC,YAEE+C,KAAYX,KAAKU,cACrBC,IAAaA,EAASZ,qBAElB,SAGJ,WCxDTP,YAAYgC,EAAmBC,kBAHZ,mBACE,OAGdD,UAAYA,OACZC,YAAcA,EAGdC,eACE1B,KAAKwB,UAAYxB,KAAKyB,mBAIpBE,EAAe,IAAIC,EAAM,EAAG,WCXhCpC,YAAYqC,EAAWC,QACvBD,EAAIA,OACJC,EAAIA,SAIAC,EAAa,IAAIC,EAAM,EAAG,OCGrBC,EAAAC,EAoBAC,EAAAC,EAQAC,EAAAC,ECnCAC,EAAAC,GDOAN,EAAAD,yFAoBAG,EAAAD,kBACT,GAAP,iBACQ,GAAR,0BACgB,GAAhB,yBACO,GAAP,wBACe,GAAf,gBAGgBG,EAAAD,sLAUX7C,sBAIO,mBAIW,kCAE2B,eAK1BmC,iBPjEH,gBACE,wBO4EE,sBAIO,iBAId,iBAIYnD,EAAUiE,2BAIA,4BACR,sBACK,kBACT,oBACI,wBACQ,uBAEb,qBAED,EAEnB7C,cACE,EAGF8C,qBAAqBC,WACrBC,UAAUF,qBAAqBC,QACb,IAAnB3C,KAAK6C,gBACFA,UAAUH,qBAAqBC,QAEnB,IAAf3C,KAAK8C,gBACIC,KAAQ/C,KAAK8C,QACjBJ,qBAAqBC,WAGT,IAAjB3C,KAAKgD,SAAyBhD,KAAKgD,QAAQpF,OAAS,YAC3CqF,KAAUjD,KAAKgD,UACjBN,qBAAqBC,WAGP,IAArB3C,KAAKkD,aAA6BlD,KAAKkD,YAAYtF,OAAS,YACnDuF,KAAcnD,KAAKkD,cACjBR,qBAAqBC,GAK/BS,UAAUC,WACVT,UAAUQ,UAAUC,QACF,IAAnBrD,KAAK6C,gBACFA,UAAUO,UAAUC,QAER,IAAfrD,KAAK8C,OAAuB9C,KAAK8C,MAAMlF,OAAS,YACvCmF,KAAQ/C,KAAK8C,QACjBM,UAAUC,WAGE,IAAjBrD,KAAKgD,SAAyBhD,KAAKgD,QAAQpF,OAAS,YAC3CqF,KAAUjD,KAAKgD,UACjBI,UAAUC,WAGI,IAArBrD,KAAKkD,aAA6BlD,KAAKkD,YAAYtF,OAAS,YACnDuF,KAAcnD,KAAKkD,cACjBE,UAAUC,GAKpBtD,aACAC,KAAKsD,uBAAyBtD,KAAKG,UAAY,IAAMH,KAAK4C,sBAEtD,MAEJ5C,KAAK4C,UAAU7C,qBAEX,KAELC,KAAK8C,OAAS9C,KAAK8C,MAAMlF,OAAS,YACzBmF,KAAQ/C,KAAK8C,UACjBC,IAASA,EAAKhD,qBAEV,KAKTC,KAAKkD,aAAelD,KAAKkD,YAAYtF,OAAS,YACrCuF,KAAcnD,KAAKkD,gBACvBC,IAAeA,EAAWpD,qBAEtB,KAKTC,KAAKgD,SAAWhD,KAAKgD,QAAQpF,OAAS,YAC7BqF,KAAUjD,KAAKgD,YACnBC,IAAWA,EAAOlD,qBAEd,SAKN,EAGFwD,4BACiB,IAAlBvD,KAAKwD,gBACAxD,KAAKwD,cAETA,SAAW,IAAIxB,EAAM,EAAG,SACvByB,EAAWzD,KAAK4C,UAAUc,SAC5BD,EAASE,aAAc,OACnBC,UAAEA,GAAcH,MAClBI,EAAS5C,KAAK6C,IAAIF,EAAU,GAAGG,WAAWlC,GAC1CmC,EAAS/C,KAAK6C,IAAIF,EAAU,GAAGG,WAAWjC,WAC5B,IAAd8B,GAA2BA,EAAUhG,OAAS,YACrCqG,KAAYL,EAAW,OAC1B/B,EAAIZ,KAAK6C,IAAIG,EAASC,SAASrC,GAC/BC,EAAIb,KAAK6C,IAAIG,EAASC,SAASpC,GACjC+B,EAAShC,MACFA,GAEPmC,EAASlC,MACFA,QAIV0B,SAAS3B,EAAIgC,OACbL,SAAS1B,EAAIkC,YAEbR,SAAS3B,EAAIZ,KAAK6C,IAAIL,EAAS/B,MAAMG,QACrC2B,SAAS1B,EAAIb,KAAK6C,IAAIL,EAAS/B,MAAMI,WAExB,IAAhB9B,KAAKmE,OAAsB,OACvBC,EAAcpE,KAAKmE,OAAOZ,yBAC3BC,SAAS3B,GAAKuC,EAAYvC,OAC1B2B,SAAS1B,GAAKsC,EAAYtC,SAE1B9B,KAAKwD,WC3NEhB,EAAAD,kBACT,GAAP,eACM,GAAN,mBACW,GAAX,yBACY,GAAZ,wBACU,GAAV,qBACS,GAAT,wBACa,GAAb,uBACQ,GAAR,cCJW8B,EAAmB,KASnBC,EAAarG,IAIH,CAAEgB,IAHAhB,EAAUsG,YAGGrF,MAFXjB,EAAUsG,YAEkBpF,KAD7BlB,EAAUsG,cAKvBC,EAAYvG,GAAiCA,EAAUwG,oBA8CvDC,EAAazG,UAClB4D,EAAY5D,EAAU0G,cACtB7C,EAAY7D,EAAU0G,qBACrB,IAAI3C,EAAMH,EAAGC,ICvET8C,EAA4B,CAAC3G,EAAsB4G,OAClD5E,MAAQhC,EAAU6G,oBAClB5E,OAASjC,EAAU6G,oBACnB3E,SAAWqE,EAASvG,KACpBmC,UAAYnC,EAAU0G,gBACtBI,gBAAkBT,EAAUrG,YCPnCuB,+BACe,aACL,sBACc,yBCFxBA,oCAC6B,UACtB,aACG,cACC,iBACG,kBACC,uBACqB,GAElCO,gBACET,OAAsC,IAArBU,KAAK6E,aAA6B7E,KAAKC,MAAQ,GAAKD,KAAKE,OAAS,GAAKF,KAAKI,UAAY,KCP7GZ,mDACgB,mBACA,cACc,gBACD,yBACU,GAErCO,aACAwB,MAAMxB,UAAYC,KAAKgF,OAAOpH,QAAU,cAEpC,YAEEyF,KAASrD,KAAKgF,WAClB3B,IAAUA,EAAM4B,sBAEZ,YAGA7G,KAAU4B,KAAKkF,YACnB9G,cAEI,SAGJ,WCxBToB,YAAY2F,EAAiBvH,kBAHJ,cACT,OAGTuH,KAAOA,OACPvH,OAASA,WCLX4B,4BACa,oBACwB,eACP,sBAED,GAE3B4F,eAAepI,QACfqI,cAAcjE,KAAKpE,GAGnBsI,4BACCC,EAAevF,KAAKuF,aAAaC,oBAClCD,kBAAe,EACbA,EAGFE,sBACCC,EAAS1F,KAAK0F,OAAOF,oBACtBE,YAAS,EACPA,0BCTTlG,YAAYmG,EAAqBC,iBAHd,mBACG,OAGfC,SAAW,IAAIC,SAASH,QACxBC,eAAiBA,OACjB7H,QAAU,IAAIgI,sBAIZ/F,KAAK6F,SAASG,uCAIdhG,KAAK6F,SAASG,WAAahG,KAAKiG,SAGlCd,cACEnF,KAAK6F,SAASF,4BAId3F,KAAKiG,SAGPC,sBACAC,YAA8B,EAAhBnG,KAAKiG,SAGnBG,oBACC1E,EAAQ1B,KAAK6F,SAASQ,QAAQrG,KAAKiG,sBACpCA,UAAY,OACZK,kBACEC,QAAQ7E,GAGV8E,WACDxG,KAAKiG,UAAYjG,KAAKpC,UAAY6I,MAAM5J,EAAU6J,qBAChDhF,EAAQ1B,KAAK6F,SAASQ,QAAQrG,KAAKiG,sBACpCA,UAAY,OACZK,kBACEK,OAAOC,aAAalF,GAGtB6C,YACDvE,KAAKiG,UAAYjG,KAAKpC,UAAY6I,MAAM5J,EAAU6J,qBAChDhF,EAAQ1B,KAAK6F,SAASgB,SAAS7G,KAAKiG,sBACrCA,UAAY,OACZK,kBACE5E,EAGFoF,WACD9G,KAAKiG,UAAYjG,KAAKpC,UAAY6I,MAAM5J,EAAU6J,qBAChDhF,EAAQ1B,KAAK6F,SAASQ,QAAQrG,KAAKiG,sBACpCA,UAAY,OACZK,kBACE5E,EAGFqF,YACD/G,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDhF,EAAQ1B,KAAK6F,SAASmB,SAAShH,KAAKiG,SAAUjG,KAAK4F,0BACpDK,UAAY,OACZK,kBACE5E,EAGF/D,aACDqC,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDhF,EAAQ1B,KAAK6F,SAASoB,UAAUjH,KAAKiG,SAAUjG,KAAK4F,0BACrDK,UAAY,OACZK,kBACE5E,EAGFwF,YACDlH,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDS,EAAOnH,KAAK6F,SAASmB,SAAShH,KAAKiG,SAAUjG,KAAK4F,cAClDwB,EAAQpH,KAAK6F,SAASQ,QAAQrG,KAAKiG,SAAW,eAC/CA,UAAY,OACZK,kBACEtG,KAAK4F,aAAeuB,EAAOE,IAAK,IAAKD,EAAQC,IAAK,IAAKF,EAAOC,EAGhEE,aACDtH,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDS,EAAOnH,KAAK6F,SAASoB,UAAUjH,KAAKiG,SAAUjG,KAAK4F,cACnDwB,EAAQpH,KAAK6F,SAASgB,SAAS7G,KAAKiG,SAAW,eAChDA,UAAY,OACZK,kBACEtG,KAAK4F,aAAeuB,EAAOE,IAAK,IAAKD,EAAQC,IAAK,IAAKF,EAAOC,EAGhEG,YACDvH,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDhF,EAAQ1B,KAAK6F,SAAS2B,SAASxH,KAAKiG,SAAUjG,KAAK4F,0BACpDK,UAAY,OACZK,kBACE5E,EAGF5D,aACDkC,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDhF,EAAQ1B,KAAK6F,SAAS4B,UAAUzH,KAAKiG,SAAUjG,KAAK4F,0BACrDK,UAAY,OACZK,kBACE5E,EAGFgG,YACD1H,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDS,EAAOnH,KAAK6F,SAAS2B,SAASxH,KAAKiG,SAAUjG,KAAK4F,cAClDwB,EAAQpH,KAAK6F,SAAS2B,SAASxH,KAAKiG,SAAW,EAAGjG,KAAK4F,0BACxDK,UAAY,OACZK,kBACEtG,KAAK4F,aAAeuB,EAAOE,IAAK,IAAKD,EAAQC,IAAK,IAAKF,EAAOC,EAGhEO,aACD3H,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDS,EAAOnH,KAAK6F,SAAS4B,UAAUzH,KAAKiG,SAAUjG,KAAK4F,cACnDwB,EAAQpH,KAAK6F,SAAS4B,UAAUzH,KAAKiG,SAAW,EAAGjG,KAAK4F,0BACzDK,UAAY,OACZK,kBACEtG,KAAK4F,aAAeuB,EAAOE,IAAK,IAAKD,EAAQC,IAAK,IAAKF,EAAOC,EAGhEzC,cACD3E,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDhF,EAAQ1B,KAAK6F,SAAS+B,WAAW5H,KAAKiG,SAAUjG,KAAK4F,0BACtDK,UAAY,OACZK,kBACE5E,EAGFmG,aACD7H,KAAKiG,UAAYjG,KAAKpC,OAAS,KAAO6I,MAAM5J,EAAU6J,qBACpDhF,EAAQ1B,KAAK6F,SAASiC,WAAW9H,KAAKiG,SAAUjG,KAAK4F,0BACtDK,UAAY,OACZK,kBACE5E,EAGFqG,iBACD/H,KAAKiG,UAAYjG,KAAKpC,UAAY6I,MAAM5J,EAAU6J,mBAClDsB,EAAU,GACVC,EAAa,UACRrH,EAAIZ,KAAKiG,SAAUrF,EAAIZ,KAAKpC,QACD,IAA9BoC,KAAK6F,SAASgB,SAASjG,GADgBA,OAIhC,IAAIZ,KAAK6F,SAASgB,SAASjG,GAAGsH,SAAS,SACpC,cAEXjC,UAAYgC,OACZ3B,kBACE6B,mBAAmBH,GAGrBI,wBAGD1G,EAAQ,EACR2G,EAAO,UACFzH,EAAI,EAAGA,EAAI,GAAIA,GAAK,EAAG,IAC1BZ,KAAKiG,UAAYjG,KAAKpC,aAClBT,MAAM,uDAGP6C,KAAK6F,SAASgB,SAAS7G,KAAKiG,eAC9BA,UAAY,MAVD,QAWerF,EACN,IAXX,yBAeX0F,kBACE5E,EAGFoD,wBACCK,EAAOnF,KAAKoI,oBACZ1G,EAAQyD,GAAQ,SACP,KAAK,GAAKzD,EAAQA,EAG5B+C,wBAGD/C,EAAQ,EACR2G,EAAO,UACFzH,EAAI,EAAGA,EAAI,GAAIA,GAAK,EAAG,IAC1BZ,KAAKiG,UAAYjG,KAAKpC,aAClBT,MAAM,uDAGP6C,KAAK6F,SAASgB,SAAS7G,KAAKiG,eAC9BA,UAAY,MAVD,QAWerF,EACN,IAXX,yBAeX0F,kBACE5E,EAGF4G,wBACCnD,EAAOnF,KAAKyE,oBACZ/C,EAAQyD,GAAQ,SACP,KAAK,GAAKzD,EAAQA,EAG5BnD,UAAUX,KACVA,GAAUA,GAAU,OACdoC,KAAKpC,OAASoC,KAAKiG,UAE1BjG,KAAKiG,SAAWjG,KAAKpC,OAASA,KAAY6I,MAAM5J,EAAU6J,qBACxD6B,EAAYvI,KAAK6F,SAASF,OAAOH,MAAMxF,KAAKiG,SAAUjG,KAAKiG,SAAWrI,eACvEqI,UAAYrI,OACZ0I,kBACE,IAAIkC,EAAUD,EAAWvI,KAAK4F,cAGhC6C,UAAUC,SACTC,EAAqB,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,IAAK,SACrDjH,EAAQ,EACR1B,KAAKmG,YAA4B,EAAdnG,KAAKpC,OAAa8K,KAAajC,MAAM5J,EAAU6J,mBAClEkC,EAAM,OACHA,EAAMF,GAAS,OACdG,EAAe5H,KAAK6H,MAAyB,KAAnB9I,KAAKmG,aAC/BA,EAAcnG,KAAKmG,YAAc,MACnCkC,EAAOrI,KAAK6F,SAASgB,SAASgC,IAAiB1C,QAC7C4C,EAAY9H,KAAK+H,IAAI,EAAI7C,EAAauC,EAAUE,MAC9CD,EAASI,MACRV,GAAQO,KACVG,OACF5C,aAAe4C,cAEjBE,qBACEvH,EAGFwH,SAASR,OACVhH,EAAQ1B,KAAKyI,UAAUC,OACjB,GAAKA,SACFhH,GAAS,GACN,GAAKgH,EAGhBS,qBACEnJ,KAAKyI,UAnQkB,GAmQqB,EAG9CW,cAAcC,SACbX,EAAU1I,KAAKmJ,cACfzH,EAAQ,IAAI4H,MAAMD,WACfzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACnBA,GAAKZ,KAAKkJ,SAASR,UAEpBhH,EAGF6H,eAAeF,SACdX,EAAU1I,KAAKmJ,cACfzH,EAAQ,IAAI4H,MAAMD,WACfzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACnBA,GAAKZ,KAAKyI,UAAUC,UAErBhH,EAGF8H,wBACwB,IAAtBxJ,KAAKyI,UAAU,GAGjBgB,cAAcJ,EAAeK,SAC5BhB,EAAU1I,KAAKmJ,cACfzH,EAAQ,IAAI4H,MAAMD,WACfzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACnBA,GAAKZ,KAAKkJ,SAASR,GAAWgB,SAE/BhI,EAGDuH,0BACDhD,SAAWhF,KAAK0I,KAAwB,KAAnB3J,KAAKmG,aAGzBG,uBACDH,YAA8B,EAAhBnG,KAAKiG,gBC5Rf2D,EAAqBC,QAC5BC,EAAc,YACPC,KAAOF,KACDE,EAAI/D,iBAEfgE,EAAS,IAAIC,WAAWH,OAC1BI,EAAS,YACFH,KAAOF,IACTM,IAAIJ,EAAKG,MACNH,EAAI/D,kBAETgE,GCvBII,EAA6BnM,UAClCL,EAASK,EAAUmK,oBACnBiC,EAAQpM,EAAUM,UAAUX,GACnB,IAAXA,KAAkB6I,MAAM5J,EAAUyN,0BAChCnF,EAAO,IAAIoF,YAAY3M,EAAS,GDVlB,EAAC4M,EAAkBC,EAAmBC,EAAkBC,EAAmBC,QAE7FH,GAAaD,EAAIxE,YACjB2E,GAAaD,EAAI1E,YACjB0E,EAAI1E,WAAa2E,EAAYH,EAAIxE,WAAayE,GAC9CG,EAAMF,EAAI1E,wBAGN6E,EAAgB,IAAIZ,WAAWO,GAC/BM,EAAgB,IAAIb,WAAWS,EAAKC,EAAWC,KACvCT,IAAIW,EAAeL,KCC1BtF,EAAM,EAAGkF,EAAMlF,OAAQ,EAAGvH,SAC3BiI,EAAW,IAAIC,SAASX,YACrB4F,SAAS,EAAG,KACZA,SAAS,EAAG,KACZA,SAAS,EAAG,KACZA,SAAS,EAAG,GACd,IAAIC,EAAS,IAAIxC,EAAUrD,GAAOvH,EAAS,ICDvCqN,EAA6B,CACxChN,EACAJ,EACAK,WAEM2G,YAAEA,GAAgB3G,SAChBL,QACDP,EAAQ4N,wBACejN,EAAW4G,cAElCvH,EAAQ6N,cAAe,OACpBxK,ECpBqB,EAAC1C,EAAsBmN,WAChDC,EAAgB,IAAIF,IACZlL,MAAQhC,EAAU6G,oBAClB5E,OAASjC,EAAU6G,oBACnB1E,UAAYnC,EAAU0G,cAChCyG,MACYE,YAAcrN,EAAU6G,oBACxByG,YAActN,EAAU6G,yBAGlC0G,EAAMpB,EAA0BnM,GAChCwN,EAAMrB,EAA0BnM,KACxBiH,QAAQ9D,KAAKoK,EAAKC,KAElBC,WAAazN,EAAUmK,4BAC5BxH,EAAI,EAAGA,EAAIyK,EAAcK,WAAY9K,IAAK,OAC3C+K,EAAa,IAAIC,IACZC,WAAa5N,EAAUuL,mBACpBxE,OAAO5D,KAAKuK,WAEnB/K,EAAI,EAAGA,EAAIyK,EAAcK,WAAY9K,IAAK,OAC3C+K,EAAaN,EAAcrG,OAAOpE,KAC7ByC,MAAQmB,EAASvG,KACjBgH,UAAYmF,EAA0BnM,MAG/CA,EAAU6N,eAAiB,EAAG,OAC1BzC,EAAQpL,EAAUmK,4BACfxH,EAAI,EAAGA,EAAIyI,EAAOzI,IAAK,OACxBmL,EAA6B,CAAE/K,MAAO,EAAGG,IAAK,KACpCH,MAAQwD,EAASvG,KACjBkD,IAAMqD,EAASvG,KACjBwC,iBAAiBW,KAAK2K,WAIjCV,GDhBcW,CAAkB/N,EAAWC,EAAUkN,YAC/CvG,YAAcA,IACXnE,UAAUU,KAAKT,gBEzBfsL,EAAAC,GCIAC,GAAAC,eCHqBzJ,EAA8B0J,EAAmBC,MAClFA,EAAUD,iBAILzL,EADI+B,EAAW/E,OACJ,EAAGgD,GAAK,EAAGA,IAAK,OAC5BG,EAAY4B,EAAW/B,QACzBG,EAAUI,IAAMkL,GAAatL,EAAUC,MAAQsL,OAG/CvL,EAAUC,MAAQqL,GAAatL,EAAUI,IAAMmL,EAAS,OACpDjL,EAAQ,CAAEL,MAAOsL,EAAU,EAAGnL,IAAKJ,EAAUI,OACzCA,IAAMkL,EAAY,EACxBhL,EAAMF,IAAME,EAAML,SACTuL,OAAO3L,EAAI,EAAG,EAAGS,GAE1BN,EAAUI,KAAOJ,EAAUC,SAClBuL,OAAO3L,EAAG,SAIrBG,EAAUC,OAASqL,GAAatL,EAAUI,KAAOmL,IACxCC,OAAO3L,EAAG,GACZG,EAAUC,MAAQqL,KACjBlL,IAAMkL,EAAY,EACxBtL,EAAUI,KAAOJ,EAAUC,SAClBuL,OAAO3L,EAAG,OAGbI,MAAQsL,EAAU,EACxBvL,EAAUI,KAAOJ,EAAUC,SAClBuL,OAAO3L,EAAG,kBAMK+B,EAA8B0J,WAErDzL,EADI+B,EAAW/E,OACJ,EAAGgD,GAAK,EAAGA,IAAK,OAC5BG,EAAY4B,EAAW/B,MACzBG,EAAUC,QAAUqL,GAAatL,EAAUI,KAAOkL,WAGlDtL,EAAUC,MAAQqL,GAAatL,EAAUI,IAAMkL,EAAW,OACtDhL,EAAQ,CAAEL,MAAOqL,EAAWlL,IAAKJ,EAAUI,OACvCA,IAAMkL,EAAY,EACxBhL,EAAMF,IAAME,EAAML,SACTuL,OAAO3L,EAAI,EAAG,EAAGS,GAE1BN,EAAUI,KAAOJ,EAAUC,SAClBuL,OAAO3L,EAAG,YFpDXsL,GAAAD,+PGEqB5L,EAAhCb,8CACyB,yBAEe,gCACZ,EAE1BI,cACExC,EAAgBoP,OAMlB1M,6BACAE,KAAKO,8BACHA,wBAAyB,OACzBC,0BAEAR,KAAKS,iBAGPV,aACAwB,MAAMxB,qBAEF,YAEE0M,KAASzM,KAAK0M,WAClBD,IAAUA,EAAM1M,qBAEZ,SAGJ,EAGDS,4BACFR,KAAKG,SAAW,EAAG,OACfkB,EAAQ,CAAEL,MAAO,EAAGG,IAAKnB,KAAKG,SAAW,QAC1CM,iBAAmB,CAACY,aACdoL,KAASzM,KAAK0M,OAAQ,IAC3B1M,KAAKS,iBAAiB7C,QAAU,UAG9B8E,qBAAqB1C,KAAKS,qBACdT,KAAKS,iBAAkBgM,EAAMJ,cAC7BrM,KAAKS,iBAAkBgM,EAAMJ,UAAYI,EAAMtM,sBC9ChEwD,oBACE,EAGFjB,qBAAqBiK,IAErBvJ,UAAUwJ,cCPZpN,oCAoBiC,qBACH,sBACE,sBACA,kBACL,qBACI,oBACD,0CAxB3BoD,EAAY,IAAIiK,YACZC,YAAc,IAAIC,KAClBD,YAAYpL,MAAQK,IACpBkE,SAAW,IAAI8G,KACf9G,SAASvE,MAAQK,IACjBiL,UAAY,IAAID,KAChBC,UAAUtL,MAAQ,IAClBuL,UAAY,IAAIF,KAChBE,UAAUvL,MAAQ,IAClBgC,MAAQ,IAAIqJ,KACZrJ,MAAMhC,MAAQ,IAAIM,EAAM,EAAG,KAC3BkL,SAAW,IAAIH,KACfG,SAASxL,MAAQ,IACjByL,QAAU,IAAIJ,KACdI,QAAQzL,MAAQ,IACnBkB,EAWFF,qBAAqBC,QACrBmK,YAAYpK,qBAAqBC,QAChB,IAAlB3C,KAAKiG,cACFA,SAASvD,qBAAqBC,SAE9BqK,UAAUtK,qBAAqBC,QAC/BsK,UAAUvK,qBAAqBC,SAEjCe,MAAMhB,qBAAqBC,QAC3BuK,SAASxK,qBAAqBC,QAC9BwK,QAAQzK,qBAAqBC,GAG7BS,UAAUC,QACVyJ,YAAY1J,UAAUC,QACL,IAAlBrD,KAAKiG,cACFA,SAAS7C,UAAUC,SAEnB2J,UAAU5J,UAAUC,QACpB4J,UAAU7J,UAAUC,SAEtBK,MAAMN,UAAUC,QAChB6J,SAAS9J,UAAUC,QACnB8J,QAAQ/J,UAAUC,GAGlBtD,qBAEkB,IAArBC,KAAK8M,mBACc,SAAb7G,eAA8C,IAAnBjG,KAAKgN,gBAA8C,IAAnBhN,KAAKiN,iBACvD,IAAfjN,KAAK0D,YACa,IAAlB1D,KAAKkN,eACY,IAAjBlN,KAAKmN,0BCvD0BC,EAA9B5N,wDAuB6B,4B3B/BX,6B2BsCsB,+BACZ,cA9BdqF,SACX4H,EAAQ,IAAIY,KACZlN,SAAW0E,EAAY1E,eACvByC,EAAY,IAAIiK,YACZC,YAAc,IAAIC,KAClBD,YAAYpL,MAAQK,IACpBkE,SAAW,IAAI8G,KACf9G,SAASvE,MAAQK,IACjB2B,MAAQ,IAAIqJ,KACZrJ,MAAMhC,MAAQ,IAAIM,EAAM,EAAG,KAC3BkL,SAAW,IAAIH,KACfG,SAASxL,MAAQ,IACjByL,QAAU,IAAIJ,KACdI,QAAQzL,M3BrBA,M2BsBZkB,UAAYA,IACZiC,YAAcA,EACb4H,EAgBF7M,cACEyC,EAAUiL,WAGZ5K,qBAAqBC,SACpBD,qBAAqBC,GACtBA,GAAoC,IAAtBA,EAAW/E,aAGzB4C,yBAGA4C,UAAUC,SACTD,UAAUC,GAGXtD,iBACAwB,MAAMxB,YAGPC,KAAK6E,YAMHrE,4BACFR,KAAKO,mCAGJA,wBAAyB,QACxBgN,EAA2BvN,KAAK6E,YAAY/E,8BACzCc,EAAI2M,EAAO3P,OAAS,EAAGgD,GAAK,EAAGA,IAAK,OACrCS,EAAmBkM,EAAO3M,KAC1BI,OAAShB,KAAKwN,uBACdrM,KAAOnB,KAAKwN,qBACdnM,EAAMF,KAAOnB,KAAKqM,YACboB,MACEpM,EAAML,MAAQhB,KAAKqM,YACtBrL,MAAQ,EACLK,EAAML,OAAShB,KAAKqM,UAAYrM,KAAKG,SAAW,IAClDsN,MACEpM,EAAMF,IAAMnB,KAAKqM,UAAYrM,KAAKG,SAAW,MAChDgB,IAAMnB,KAAKqM,UAAYrM,KAAKG,SAAW,QAG5CM,iBAAmB8M,oBCpFIH,EAAzB5N,gDACmC,GAEjCI,cACEyC,EAAUqL,MAGZhL,qBAAqBC,SACpBD,qBAAqBC,aAChBgL,KAAW3N,KAAK4N,WACjBlL,qBAAqBC,GAI1BS,UAAUC,SACTD,UAAUC,aACLsK,KAAW3N,KAAK4N,WACjBxK,UAAUC,GAIftD,aACAwB,MAAMxB,gBACF,YAGE4N,KAAW3N,KAAK4N,iBACT,IAAZD,IAA0BA,EAAQ5N,gBAC7B,SAGJ,oBC9BqBqN,EAAzB5N,kDACsBR,aACZ,cACC,EAETY,cACEyC,EAAUwL,MAGZnL,qBAAqBC,SACpBD,qBAAqBC,GAGtBS,UAAUC,SACTD,UAAUC,GAGXtD,gBACAwB,MAAMxB,SAIJT,EAAiBU,KAAKC,MAAQ,GAAKD,KAAKE,OAAS,SAF/C,qBCvBuBkN,EAC3BxN,cACEyC,EAAUyL,oBCDdtO,6BAGc,eACF,yBACqCZ,EAA0BmP,oBAC/C,iBACD,mBACLhM,iBACDA,EAEnBiM,cAEAC,SAASrB,UACP5M,KAAK+D,WAGPmK,aAAaC,UACXA,GAAQnO,KAAKqM,WAAa8B,EAAOnO,KAAKsM,0BChBNS,GAGlCvN,YAAmBoE,mDAFE,OAIR,IAAdA,GAA2BA,EAAUhG,OAAS,SAC3C8D,MAAQkC,EAAU,GAAGG,sBAEjBE,KAAYL,IACZoK,aAINrK,oBACE,EAGFjB,qBAAqBC,aACfsB,KAAYjE,KAAK4D,iBAClBK,EAASmK,wBACVxP,EAA0ByP,YAC1BzP,EAA0B0P,UACN3L,EAAYsB,EAASoI,UAAWpI,EAASqI,QAAU,oBAGxD3J,EAAYsB,EAASoI,cACrB1J,EAAYsB,EAASqI,UAMxClJ,UAAUC,OACXkL,EAAevO,KAAK4D,UAAU5D,KAAKwO,sBACnCD,EAAaL,aAAa7K,QACvB3B,MAAQ6M,EAAaN,SAAS5K,WAGjCA,EAAQkL,EAAalC,eAChBrM,KAAKwO,kBAAoB,SACzBA,mBAAqB,GACtBxO,KAAK4D,UAAU5D,KAAKwO,mBAAmBN,aAAa7K,gBAKnDrD,KAAKwO,kBAAoBxO,KAAK4D,UAAUhG,OAAS,SACjD4Q,mBAAqB,GACtBxO,KAAK4D,UAAU5D,KAAKwO,mBAAmBN,aAAa7K,QAK7CrD,KAAK4D,UAAU5D,KAAKwO,mBAC/BnL,GAASkL,EAAalC,eACnB3K,MAAQ6M,EAAaxK,WACjBV,GAASkL,EAAajC,aAC1B5K,MAAQ6M,EAAarK,cAErBxC,MAAQ6M,EAAaN,SAAS5K,MVxDvB+I,GAAAD,sTA0BLsC,GAAe,CAAIxQ,EAAsBC,EAAcwQ,WAC5DC,EAAyBD,EACzBE,EAA8B,OAC/BD,EAAUE,SAAwC,IAA7BF,EAAUE,QAAQjR,cACnCM,YAEE4Q,KAAUH,EAAUE,QAAS,OAChCE,EAAOC,GAAkB/Q,EAAW6Q,KACpC1N,KAAK2N,KAEH7I,qBACN+I,EAAQ,YACDH,KAAUH,EAAUE,QAAS,OAChCE,EAAOH,EAAMK,GACbC,EAASJ,EAAOK,MACfC,cAAcnR,EAAW8Q,EAAM7Q,EAA4BgR,MACzD,SAEJhR,YAiBAsB,YAAY2P,EAAaE,EAA8BC,QACvDD,cAAgBA,OAChBC,aAAeA,OACfH,IAAMA,EAGNC,cAAcG,EAAuBC,EAAsBC,EAAsBC,IAEjFC,UAAUJ,IAIVK,cAAcL,EAAuBM,EAAmBC,IAExDC,wBACE,EAGFC,YAAYR,UACV,IAAIS,UAIFb,GAAgB,CAC3BnR,EACA8Q,EACAmB,EACAhB,EACAJ,KAE6B,IAAzBA,EAAOO,gBACGH,GAAUH,EAAKoB,MACO,IAAzBrB,EAAOO,gBACJH,GAAUJ,EAAOa,UAAU1R,GACL,IAAzB6Q,EAAOO,gBACJH,GAAUS,GAAU1R,EAAW6Q,EAAQC,KAEvCG,GAAUkB,GAAanS,EAAW6Q,EAAQC,IAI7CqB,GAAe,CAAInS,EAAsB6Q,EAAuBC,SACvEtL,KACAsL,EAAKoB,SACHpB,EAAKpL,WAAY,OACbC,EAAgCyM,GAAcpS,EAAW6Q,EAAQC,OAClEnL,GAAkC,IAArBA,EAAUhG,YACpB,gCAGSK,EAAW2F,EAAWkL,MAC1B7Q,EAAW2F,EAAWkL,GAC/BC,EAAKuB,aAGE,IAAIC,GAAsB3M,UAE1B,IAAImJ,KACNrL,MAAQiO,GAAU1R,EAAW6Q,EAAQC,UAGrC,IAAIhC,KACNrL,MAAQoN,EAAOQ,oBAEnB7L,GAGIkM,GAAY,CAAC1R,EAAsB6Q,EAAuBC,IACjEA,EAAKoB,MACArB,EAAOa,UAAU1R,GAEnB6Q,EAAOQ,aAGHN,GAAoB,CAAC/Q,EAAsB6Q,WAChDC,EAAsB,CAAEoB,OAAO,EAAOxM,YAAY,EAAO2M,YAAY,IACrEjB,cAAEA,GAAkBP,SACJ,IAAlBO,KACGc,OAAQ,EACNpB,MAEJoB,MAAQlS,EAAUuL,iBAEpBuF,EAAKoB,OACY,IAAlBd,GACkB,IAAlBA,GACkB,IAAlBA,KAIG1L,WAAa1F,EAAUuL,iBACvBuF,EAAKpL,YAAgC,IAAlB0L,KAGnBiB,WAAarS,EAAUuL,iBACrBuF,GAHEA,GAJAA,IAUEsB,GAAgB,CAC3BpS,EACA6Q,EACAC,WAEMnL,EAAwB,GACxB4M,EAAoBvS,EAAUmK,4BAC3BxH,EAAI,EAAGA,EAAI4P,EAAW5P,IAAK,KAC9BqD,KACyB,IAAzB6K,EAAOO,gBACE,IAAIY,OACV,OACC7B,EAAoBnQ,EAAUwK,UAAU,GAC1C2F,IAAsBxP,EAA0BmP,OACvC,IAAIkC,MAEJnB,EAAOkB,YAAYjB,KACrBX,kBAAoBA,KAGvBhN,KAAK6C,UAGVL,GAGH6M,GAAmB,CAAIxS,EAAsB2F,EAA+BkL,WAC1E0B,EAAoB5M,EAAUhG,SAC1B,GAAGyO,UAAY7H,EAASvG,WACzB2C,EAAI,EAAGA,EAAI4P,EAAW5P,IAAK,OAC5BuN,EAAe3J,EAASvG,KACpB2C,GAAG0L,QAAU6B,EACnBvN,EAAI4P,EAAY,MACR5P,EAAI,GAAGyL,UAAY8B,SAG3BuC,EAAiB,KAChBd,cAAc3R,EAAWyS,EAAMF,EAAY,OAC9CvB,EAAQ,IACF,GAAGlL,WAAa2M,EAAKzB,MACtB,UACArO,EAAI,EAAGA,EAAI4P,EAAW5P,IAAK,OAC5Bc,EAAQgP,EAAKzB,MACV,IACCrO,GAAGsD,SAAWxC,EACpBd,EAAI4P,EAAY,MACR5P,EAAI,GAAGmD,WAAarC,KAK9BiP,GAAe,CAAI1S,EAAsB2F,EAA+BkL,WACtEiB,EACqB,IAAzBjB,EAAOO,cAAyDP,EAAOiB,iBAAmB,EACtFrH,EAAkBzK,EAAUkL,wBACvBlF,KAAYL,EAAW,IAC5BK,EAASmK,oBAAsBxP,EAA0ByP,oBAGzDxM,EACAC,UACKlB,EAAI,EAAGA,EAAImP,EAAgBnP,MAC9B3C,EAAUiL,SAASR,GAAWrE,IAC9BpG,EAAUiL,SAASR,GAAWrE,IACzBuM,UAAUxP,KAAK,CAAES,EAAAA,EAAGC,EAAAA,MACzB7D,EAAUiL,SAASR,GAAWrE,IAC9BpG,EAAUiL,SAASR,GAAWrE,IACzBwM,SAASzP,KAAK,CAAES,EAAAA,EAAGC,EAAAA,kBW1ODgP,EAAWC,EAAWC,UAC9CF,KAASA,GAAKE,WCAdC,iBAAiBC,UACfA,oBCIsCjB,GAA1CzQ,0DACiC,0BACA,EAE/BwO,mBACCA,aACFhO,KAAKoO,oBAAsBxP,EAA0ByP,cAKlD8C,cAAgB,IAAIC,QACpBC,cAAgB,IAAID,IAItBnD,SAASE,SACRmD,KAAmBtR,KAAKqM,iBAAmBC,QAAUtM,KAAKqM,WAC1DkF,EAAYvR,KAAKmR,cAAcF,iBAAiBK,GAChDE,EAAYxR,KAAKqR,cAAcJ,iBAAiBK,SAG/C,CAAEzP,EAFC4P,GAAiBzR,KAAK+D,WAAWlC,EAAG7B,KAAKkE,SAASrC,EAAG0P,GAEnDzP,EADF2P,GAAiBzR,KAAK+D,WAAWjC,EAAG9B,KAAKkE,SAASpC,EAAG0P,sBCtBxBvB,GAApCzQ,yDACgC,EAE9BwO,aACDhO,KAAKoO,oBAAsBxP,EAA0ByP,cAGlDqD,aAAe,IAAIN,IAIrBO,YAAYxD,SACXmD,KAAmBtR,KAAKqM,iBAAmBC,QAAUtM,KAAKqM,kBACzDrM,KAAK0R,aAAaT,iBAAiBK,GAGrCrD,SAASE,SACRmD,EAAWtR,KAAK2R,YAAYxD,UAC3BsD,GAAiBzR,KAAK+D,WAA6B/D,KAAKkE,SAA2BoN,qBCCpDM,GACjCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,UACRA,EAAU0G,cAGZiL,cAAc3R,EAAsByS,EAAqBrH,WACrDzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBQ,KAAKpB,KAAK2P,UAAU1R,IAItB8R,wBACE,EAGFC,YAAYR,UACV,IAAIqC,qBAI0BD,GAChCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,UACRA,EAAUmI,cAGZwJ,cAAc3R,EAAsByS,EAAsBrH,WACtDzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBQ,KAAKnD,EAAUuL,kBAIjBuG,wBACE,EAGFC,YAAYR,UACV,IAAIS,qBAI2B2B,GACjCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,UACRA,EAAUsG,YAGZqL,cAAc3R,EAAsByS,EAAqBrH,SACxDyI,EAAY7T,EAAUsL,eAAeF,WAClCzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBQ,KAAK0Q,EAAUlR,IAIjBmP,wBACE,EAGFC,YAAYR,UACV,IAAIqC,qBA8B0BD,GAChCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,UACRuG,EAASvG,GAGX2R,cAAc3R,EAAsByS,EAAqBrH,WACrDzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBA,GAAKZ,KAAK2P,UAAU1R,GAItB8R,wBACE,EAGFC,YAAYR,UACV,IAAIqC,qBAI2BD,GACjCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,UACRyG,EAAUzG,GAGZ2R,cAAc3R,EAAsByS,EAAoBrH,MACzDrJ,KAAKqP,gBAAkBlD,GAAc4F,gBAAiB,OAClDC,EAAmB/T,EAAUwL,cAAsB,EAARJ,E5B1KtB,a4B2KlBzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBA,OAAYA,GAAK,IAAIoB,EAAM,EAAG,MAC9BpB,GAAGiB,EAAImQ,EAAOpR,gBAGZA,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBA,GAAK8D,EAAUzG,GAKnB8R,wBACE,EAGFC,YAAYR,UACTxP,KAAKqP,oBACNlD,GAAc8F,8BACV,IAAIC,kBAEJ,IAAIL,sBAiCuBD,GACjCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,S5BtOM,CAACA,UAClBkU,EAAyBlU,EAAU6G,kBACnCsN,EAA2BnU,EAAUmK,2BACrB,IAAIxG,EAAMuQ,EAAgBC,I4BoOvCC,CAAUpU,GAGZ2R,cAAc3R,EAAsByS,EAAoBrH,WACpDzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBA,GAAKZ,KAAK2P,UAAU1R,GAItB8R,wBACE,EAGFC,YAAYR,UACV,IAAIqC,qBAgC2BD,GACjCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,S5BrQQ,CAACA,UACpBqU,EAAarU,EAAUmK,uBACzBkK,EAAK,EAAG,OACJ7F,EAAe,IAAIW,WACnBkF,GAAKA,EACJ7F,I4BiQA8F,CAAYtU,GAGd2R,cAAc3R,EAAsByS,EAAoBrH,WACpDzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBA,GAAKZ,KAAK2P,UAAU1R,GAItB8R,wBACE,EAGFC,YAAYR,UACV,IAAIqC,UCvSFW,GAAgD,CAC3DC,QAASnV,EAAQoV,gBACjB7D,QAAS,CACP,IAAI8D,GAAoB,WAAYxG,GAAcyG,SAAS,GAC3D,IAAID,GAAoB,kBAAmBxG,GAAcyG,SAAS,GAClE,IAAIC,GAAqB,SAAU1G,GAAc2G,WAAO,GACxD,IAAIC,GAAqB,UAAW5G,GAAc2G,MAAOnR,GACzD,IAAIqR,GAAoB,YAAa7G,GAAc2G,MtCvB9B,GsCwBrB,IAAIG,GAAqB,YAAa9G,GAAc2G,MAAOtU,EAAUiE,QACrE,IAAIwQ,GAAqB,iBAAkB9G,GAAc2G,MAAO3Q,EAAe+Q,MAC/E,IAAIC,GAAqB,YAAahH,GAAciH,eAAgB,GACpE,IAAIJ,GAAoB,WAAY7G,GAAckH,WtC3B7B,KsC+BZC,GAAkD,CAC7Db,QAASnV,EAAQiW,kBACjB1E,QAAS,CACP,IAAI8D,GAAoB,WAAYxG,GAAcyG,SAAS,GAC3D,IAAID,GAAoB,kBAAmBxG,GAAcyG,SAAS,GAClE,IAAIC,GAAqB,SAAU1G,GAAc2G,WAAO,GACxD,IAAIC,GAAqB,UAAW5G,GAAc2G,MAAOnR,GACzD,IAAIqR,GAAoB,YAAa7G,GAAc2G,MtCtC9B,GsCuCrB,IAAIG,GAAqB,YAAa9G,GAAc2G,MAAOtU,EAAUiE,QACrE,IAAIwQ,GAAqB,iBAAkB9G,GAAc2G,MAAO3Q,EAAe+Q,MAC/E,IAAIC,GAAqB,YAAahH,GAAciH,eAAgB,GACpE,IAAIJ,GAAoB,WAAY7G,GAAckH,WtC1C7B,GsC2CrB,kBDwNuCzB,GAClCpS,YAAY2P,EAAaE,EAA8BC,SACtDH,EAAKE,EAAeC,GAGrBF,cAAcnR,EAAsB8Q,EAAqBmB,EAAqBhB,MACrEjR,EAAW8Q,EAAMmB,EAAahB,EAAQlP,MAG/C2P,UAAU1R,UACRA,EAAU8J,iBAGZ6H,cAAc3R,EAAsByS,EAAqBrH,WACrDzI,EAAI,EAAGA,EAAIyI,EAAOzI,MACpBA,GAAKZ,KAAK2P,UAAU1R,GAItB8R,wBACE,EAGFC,YAAYR,UACV,IAAIqC,KChPe,OAAQ1F,GAAc2G,MAAO,MAI9CU,GAA4C,CACvDf,QAASnV,EAAQuP,YACjBgC,QAAS,CACP,IAAI4E,GAAqB,cAAetH,GAAc4F,gBAAiBhQ,GACvE,IAAI0R,GAAqB,WAAYtH,GAAc4F,gBAAiBhQ,GACpE,IAAIoR,GAAqB,YAAahH,GAAciH,eAAgB,GACpE,IAAID,GAAqB,YAAahH,GAAciH,eAAgB,GACpE,IAAIK,GAAqB,QAAStH,GAAc8F,uBAAwB,IAAIjQ,EAAM,EAAG,IACrF,IAAImR,GAAqB,WAAYhH,GAAciH,eAAgB,GACnE,IAAIH,GAAqB,UAAW9G,GAAciH,etCvDhC,OsC4DX9V,EAAQoW,gBClBNC,GAAkB,CAAC1V,EAAsBJ,EAAe4O,YAC3D5O,QACDP,EAAQoV,mBACEzU,EAAWwO,EAAO+F,IAC3B/F,EAAMtM,UAAY,MAASA,SAAW,cAEvC7C,EAAQiW,qBACEtV,EAAWwO,EAAO6G,IAC3B7G,EAAMtM,UAAY,MAASA,SAAW,cAEvC7C,EAAQuP,cACLjK,UAAY,IAAIiK,MACT5O,EAAWwO,EAAM7J,UAAW4Q,IAGvC/G,EAAM7J,UAAUqD,SAAStC,cACzB8I,EAAM7J,UAAUqD,SAASvE,QAAUK,MAC1Ba,UAAUoK,UAAUrJ,cAAoD,IAApC8I,EAAM7J,UAAUoK,UAAUtL,UAC7DkB,UAAUqK,UAAUtJ,cAAoD,IAApC8I,EAAM7J,UAAUqK,UAAUvL,SAElEkB,UAAUoK,eAAY,IACtBpK,UAAUqK,eAAY,KAEtBrK,UAAUqD,cAAW,aAG1B3I,EAAQsW,WACPnH,EAAM7M,SAAWyC,EAAUwL,gBCnEN5P,EAAsBwO,KAC7CoH,WAAavP,EAAUrG,KACvBgC,MAAQhC,EAAU6G,oBAClB5E,OAASjC,EAAU6G,mBDiEJ7G,EAAWwO,cAGzBnP,EAAQwW,qBACPrH,EAAM7M,SAAWyC,EAAUiL,qBEvEIrP,EAAsBwO,SACvD6F,EAAKrU,EAAUmK,oBACjBkK,EAAK,MACDzN,YAAc,IAAIxE,IAClBwE,YAAYyN,GAAKA,KAEnB9E,qBAAuBhJ,EAASvG,IFkEPA,EAAWwO,KGxD/BsH,GAA8B,CAAC9V,EAAsBJ,EAAegH,YACvEhH,QACDP,EAAQ4N,wBACejN,EAAW4G,cAElCvH,EAAQ0W,aACCtH,OAAOtL,KHRA,CAACnD,QAEpBwO,SADyBxO,EAAUsG,kBAGhClC,EAAUyL,YACL,IAAImG,cAET5R,EAAUwL,QACL,IAAIqG,cAET7R,EAAUqL,QACL,IAAIyG,cAET9R,EAAUiL,aACL,IAAID,mBAGJ,IAAID,WAGVkF,GAAKrU,EAAUmK,sBACZnK,EAAWwO,EAAOkH,IACpBlH,GGdqB2H,CAAUnW,MAO3BoW,GAA8B3H,QACpCA,GAA4B,IAAlBA,EAAO9O,oBAGhB0W,EAAW,IAAIC,cACV9H,KAASC,EACbD,OAGiBA,KACbtC,IAAIsC,EAAM6F,GAAI7F,QAGrBwC,EAAQ,YACDxC,KAASC,KACbD,WAGgB,IAAjBA,EAAMtI,OAAsB,OACxBqQ,EAAK/H,EAAMtI,OAAOmO,GAClBtI,EAASsK,EAASG,IAAID,QACb,IAAXxK,MACI7F,OAAS6F,MAGfiF,EAAQ,GAAKyF,GAAcjI,EAAMkI,oBAC7BC,gBAAkBlI,EAAOuC,EAAQ,SAEnB,IAAlBxC,EAAMzJ,SAAyByJ,EAAMzJ,QAAQpF,OAAS,YAC7CqF,KAAUwJ,EAAMzJ,QACpBC,IAGDA,EAAOrD,OAAWqM,EAAW4I,oBAY5B,IAQAC,GAAyBrI,QAC/BA,IAAUA,EAAM3J,OAAgC,IAAvB2J,EAAM3J,MAAMlF,oBAGpCmX,EAAU,IAAIR,cACTxR,KAAQ0J,EAAM3J,MAClBC,KAGGoH,IAAIpH,EAAKuP,GAAIvP,WAED,IAAlB0J,EAAMzJ,SAAyByJ,EAAMzJ,QAAQpF,OAAS,YAC7CqF,KAAUwJ,EAAMzJ,WACpBC,WAGyB,IAA1BA,EAAO+R,gBAAgC/R,EAAO+R,eAAepX,OAAS,EAAG,OACrEoX,EAAiB,IAAI1L,gBAChBvG,KAAQE,EAAO+R,eAAgB,OAClCR,EAAKzR,EAAKuP,GACVtI,EAAS+K,EAAQN,IAAID,QACZ,IAAXxK,KACa5I,KAAK4I,KAGjBgL,eAAiBA,SAElB/R,EAAOrD,aACRqM,EAAWgJ,aAC0B,IAAnChS,EAAsBiS,SAAwB,OAC3CV,EAAMvR,EAAsBiS,SAAS5C,GACrCtI,EAAS+K,EAAQN,IAAID,QACZ,IAAXxK,IACD/G,EAAsBiS,SAAWlL,cAInCiC,EAAWkJ,OAAQ,OAChBC,EAAenS,KAChBmS,EAAaC,UAAQ,EAAY,OAC9Bb,EAAKY,EAAaC,KAAK/C,GACvBtI,EAAS+K,EAAQN,IAAID,QACZ,IAAXxK,MACWqL,KAAOrL,cAW5ByC,EAAM7M,SAAWyC,EAAUiT,KAAM,OAC7BC,WAAEA,GAAe9I,sBACL4I,KAAM,OAChBb,EAAKe,EAAWF,KAAK/C,GACrBtI,EAAS+K,EAAQN,IAAID,QACZ,IAAXxK,MACSqL,KAAOrL,MAMb0K,GAAiB9U,WACpBA,QACDuC,EAAeqT,WACfrT,EAAesT,qBACX,iBAEA,gBCzJkBxX,EAAsBJ,EAAeE,UAC1DF,QACDP,EAAQoY,yBACHnQ,aAAanE,KDIU,CAACnD,UAC9B4G,EAAc,IAAI8Q,YACZrD,GAAKrU,EAAUmK,sBAClBnK,EAAW4G,EAAakP,OACNlP,EAAY6H,QAChC7H,GCTuB+Q,CAAsB3X,eAE7CX,EAAQuY,wBACHtQ,aAAanE,KxBLS,CAACnD,UAC7B4G,EAAc,IAAIiR,WACZxD,GAAKrU,EAAUmK,sBACfgD,SAAWnN,EAAUmI,gBAExBnI,EADS,CAAE4G,YAAAA,EAAauG,SAAUvG,EAAYuG,UACxBH,GACxBpG,GwBDuBkR,CAAqB9X,cCa9CuB,0BAYmB,CACtBS,MAAO,EACPC,OAAQ,EACRE,UAAW,EACXD,SAAU,EACViL,UAAU,EACVxI,UAAW,IAAIiK,GACfmJ,WAAY,EACZC,YAAa,iBAnBMC,GACdA,KAAUzP,MAAM5J,EAAUsZ,kBACzBC,EAAY,IAAIC,UAClBH,EAAKI,gBAAgB1W,SAAWxC,EAAgBkD,QACxCiW,iCAAiCL,EAAKI,iBACvCJ,EAAKI,gBAAgB1W,SAAWxC,EAAgBoP,UAC/CgK,kCAAkCN,EAAKI,iBAE5CF,EAeFK,aACAzW,KAAKW,YAAc8F,MAAM5J,EAAU6Z,mB3BrCC,CAAC7M,UACtC8M,EAAc9M,EAAO+M,KAAK7M,GAAQ,IAAIE,WAAWF,YAChDH,EAAkB+M,I2BuCPE,CADA,IAFD7W,KAAKW,SAASuE,QAAQ0R,KAAKE,GAAWA,EAAO3R,KAAKA,YACpDnF,KAAKW,SAASqE,OAAO4R,KAAKvT,GAAUA,EAAM4B,UAAUE,KAAKA,WAMjE4R,aACA/W,KAAKW,uBACEX,KAAKW,SAASqE,OAAO4R,KAAKvT,GAAUA,EAAMA,QAIhDkT,iCAAiC1R,GACnCA,EAAYnE,UAAU9C,OAAS,KAAO6I,MAAM5J,EAAU6Z,kBACrDM,OAAO/W,MAAQ4E,EAAY5E,WAC3B+W,OAAO9W,OAAS2E,EAAY3E,YAC5B8W,OAAO5W,UAAYyE,EAAYzE,eAC/B4W,OAAO7W,SAAW0E,EAAY1E,cAC9B6W,OAAOhB,WAAanR,EAAY5E,WAChC+W,OAAOf,YAAcpR,EAAY3E,YACjC8W,OAAO5L,WAAavG,EAAYuG,eAC/BzK,EAAWkE,EAAYnE,UAAUmE,EAAYnE,UAAU9C,OAAS,QACjE+C,SAAWA,OACXqW,OAAOpU,UAAYiK,GAAYoK,2BAG9BT,kCAAkC3R,OACpCqS,EAAiB,YACVzK,KAAS5H,EAAY6H,OAAQ,IAClCD,EAAM7M,SAAWyC,EAAUiL,0BAEzB6J,EAAe1K,EAA0B5H,YAC3CsS,EAAYvX,SAAWxC,EAAgBkD,OAAS6W,EAAYzW,UAAU9C,QAAU,OAChE,GAGhBsZ,EAAiB,KACfzQ,MAAM5J,EAAUua,4BAGpBF,EAAiB,KACfzQ,MAAM5J,EAAU6Z,kBAGjBM,OAAO/W,MAAQ4E,EAAY5E,WAC3B+W,OAAO9W,OAAS2E,EAAY3E,YAC5B8W,OAAO5W,UAAYyE,EAAYzE,eAC/B4W,OAAO7W,SAAW0E,EAAY1E,mBAExBsM,KAAS5H,EAAY6H,OAAQ,IAClCD,EAAM7M,SAAWyC,EAAUiL,0BAEzB+J,EAAoB5K,EAA0B5H,eAChDwS,EAAiBzX,SAAWxC,EAAgBkD,OAAS+W,EAAiB3W,UAAU9C,OAAS,gBACxFoZ,OAAOhB,WAAaqB,EAAiBpX,WACrC+W,OAAOf,YAAcoB,EAAiBnX,YACtC8W,OAAO5L,WAAaiM,EAAiBjM,eACpCzK,EAAW0W,EAAiB3W,UAAU2W,EAAiB3W,UAAU9C,OAAS,QAC3E+C,SAAWA,OACXqW,OAAOpU,UAAa6J,EAA0B7J,0DCtG9C,EACJ0U,GAAKC,KAAM,OACXD,GAAKE,KAAM,OACXF,GAAK9L,KAAM,OACX8L,GAAK7L,KAAM,OACX6L,GAAKG,KAAM,OACXH,GAAKI,KAAM,0BAIUC,UACpBA,EAAKC,eAAeN,GAAKO,MACpBP,GAAKO,MAAMF,EAAKC,aAElB,UAUTpY,YAAY2F,QACL2S,QAAU3S,OACV4S,WAA+B,QAAbD,QAAQ,KAAc,OACxCF,YAAgC,GAAlB5X,KAAK8X,QAAQ,QAC3BE,MAA6B,IAArBhY,KAAK4X,aAA0C,IAArB5X,KAAK4X,iBACvCK,UAAY,OACZC,gBAAiB,EAGjBhQ,iBACE,GAAGoP,GAAKO,MAAM7X,KAAK4X,sBAAsB5X,KAAK+X,YAGhDlM,oBACE7L,KAAK4X,cAAgBN,GAAKC,IAG5BY,wBACEnY,KAAK8X,QAAQ9R,WAGfoS,iBACE,EAAIpY,KAAKmY,iBAGXE,gBACCrO,EAAS,IAAIC,WAAWjK,KAAKoY,kBACtB,IAAItS,SAASkE,EAAOrE,QAC5B2S,UAAU,EAAGtY,KAAKoY,UAAY,KAC5BjO,IAAInK,KAAK8X,QAAS,GAClB9N,cA/DJuO,GACSd,IAAM,EADfc,GAEShB,IAAM,EAFfgB,GAGSf,IAAM,EAHfe,GAIS/M,IAAM,EAJf+M,GAKS9M,IAAM,EALf8M,GAMSb,IAAM,WCDpBlY,YAAY2F,QACLA,KAAOA,OACP8J,MAAQ,OACRlG,UAA8B,EAAlB5D,EAAKa,sCAIfhG,KAAK+I,UAAY/I,KAAKiP,MAGxBuJ,SAASC,MACVzY,KAAK0Y,cAAgBD,SAChB,OAEJxJ,OAASwJ,EAGTvP,SAASuP,EAAcE,GAAY,UACzB3Y,KAAK4Y,QAAQH,EAAMzY,KAAKiP,MAAO0J,GAIzCE,aACDC,MACCA,EAAmB,EAAGA,EAAmB9Y,KAAK+I,UAAY/I,KAAKiP,QAAS6J,KACb,IAA1D9Y,KAAK4Y,QAAQ,EAAG5Y,KAAKiP,MAAQ6J,GAAkB,eAC5C7J,OAAS6J,EACPA,SAGJA,EAGFC,eACAP,SAAS,EAAIxY,KAAK6Y,UAGlBG,cACAR,SAAS,EAAIxY,KAAK6Y,UAGlBI,gBACCC,EAASlZ,KAAK6Y,gBACb7Y,KAAKkJ,SAASgQ,EAAS,GAAK,EAG9BC,eACCzX,EAAQ1B,KAAKiZ,iBACf,EAAOvX,EACD,EAAIA,IAAW,UAEF,GAGlB0E,qBACuB,IAArBpG,KAAKkJ,SAAS,GAGhBkQ,UAAUC,EAAgB,UACxBrZ,KAAKkJ,SAAyB,EAAhBmQ,GAGhBC,oBACEtZ,KAAKkJ,SAAS,IAGhBqQ,kBACEvZ,KAAKkJ,SAAS,IAGhBsQ,aACDC,EAAI,EACJ7Y,EAAI,OACoB,IAArBZ,KAAKkJ,SAAS,IAAYtI,EAAI,IAAMZ,KAAK0Y,kBACzC,WAEH1Y,KAAKkJ,SAAStI,UACPA,GAAK,EACT6Y,EAGDb,QAAQH,EAAciB,EAAoBf,GAAY,MACxD3Y,KAAK0Y,cAAgBD,SAChB,QAEHvO,EAASwP,EAAa,EACtBrR,EAAOrI,KAAKmF,KAAMuU,EAAa,EAAK,GAAM,MAASxP,EACnDyP,EAAO,EAAIzP,KACbyP,GAAQlB,SACNE,SACG1J,OAASwJ,GAETpQ,GAASsR,EAAOlB,EAErBE,SACG1J,OAAS0K,SAEVC,EAAWnB,EAAOkB,SAChBtR,GAAQuR,EAAY5Z,KAAK4Y,QAAQgB,EAAUF,EAAaC,EAAMhB,wCC3FtChY,SACzB,IACFA,EAASuE,QAAQ0R,KAAKxY,GAAW,IAAI6L,WAAW7L,EAAO+G,KAAKA,OAAQ,QACpExE,EAASqE,OAAO4R,KAAKvT,GAAU,IAAI4G,WAAW5G,EAAM4B,UAAUE,KAAKA,OAAQ,2BAItD0U,GACtBA,EAAMjc,OAAS,KAAO6I,MAAM5J,EAAUid,eACpC9U,EAAsB,OACxB+U,EAAqB,GACrBC,GAAa,EACbhC,GAAQ,YACDL,KAAQkC,EAAO,OAClBI,EAAO,IAAI1B,GAAKZ,GAClBsC,EAAKrC,cAAgBW,GAAKhB,KAAO0C,EAAKrC,cAAgBW,GAAKd,QAClDyC,YAAYD,GAErBF,EAAMnc,QAAUoa,MAAeE,iBAAmB+B,EAAKjC,WAClD5W,KAAK,CAAE2Y,MAAAA,EAAOC,WAAAA,MACb,MACK,KACL,KAEJ5Y,KAAK6Y,KACED,GAAcC,EAAKpO,eACxBmM,GAASiC,EAAKjC,SAEpB+B,EAAMnc,OAAS,KACboa,IACK5W,KAAK,CAAE2Y,MAAAA,EAAOC,WAAAA,QAChB,OACCG,EAAOnV,EAAOpH,OAAS,IACtBuc,GAAMJ,MAAQ/U,EAAOmV,GAAMJ,MAAMK,OAAOL,UAG5C/U,qBAGiB2S,SAClB0C,EAAU,IAAIC,GAAU3C,EAAKG,WAC3BsB,cACHlB,eAAuC,IAAtBmC,EAAQpB,YACzBhB,UAAYoC,EAAQpB,0BAGJtB,SACf1X,MAAEA,SAAOC,GAAWqa,GAAWC,QAAQ7C,GACvCnM,EAAM,IAAIvB,WAAW0N,OACvB8C,EAAQ,cACNC,EAAa,IAAI5U,SAAS6R,EAAKhS,OAAQgS,EAAKgD,WAAa,EAAG,WACzD/Z,EAAI,EAAGA,EAAI,IAAKA,EAAG,KACtBga,EAAIF,EAAW7T,SAASjG,GAAGsH,SAAS,IACpC0S,EAAEhd,OAAS,MACT,IAAIgd,QAEDA,QAEJ,CAAEpP,IAAAA,EAAKiP,MAAAA,EAAOxa,MAAAA,EAAOC,OAAAA,0BAGAma,EAAShR,OAGjCwR,EAFAC,EAAY,EACZC,EAAY,UAEPC,EAAI,EAAGA,EAAI3R,EAAO2R,IACP,IAAdD,MACWV,EAAQlB,cACI0B,EAAa,KAAO,OAErB,IAAdE,EAAkBD,EAAYC,iBAIxB5V,SAEdkV,EAAU,IAAIC,GAAUnV,OAM1B8V,EACAC,EANAC,EAAsB,EACtBC,EAAuB,EACvBC,EAAqB,EACrBC,EAAwB,EACxBC,EAAW,IAGPrS,SAAS,KACTA,SAAS,KACTA,SAAS,SACXsS,EAAanB,EAAQjB,iBACnBlQ,SAAS,KACTA,SAAS,KACTkQ,cACAI,SAhBc,CAAC,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,IAAK,KAkB1CiC,QAAQD,MAAkB,OACpCE,EAAkBrB,EAAQb,SACR,IAApBkC,KACMlD,SAAS,KAEXgB,WACAA,WACAhB,SAAS,MACmB6B,EAAQjU,cACX,GACQ,IAApBsV,EAAwB,EAAI,WACtC9a,EAAI,EAAGA,EAAIsa,IAAoBta,EAClCyZ,EAAQjU,gBAENxF,EAAI,KACK+a,gBAAgBtB,EAAS,OAEzBsB,gBAAgBtB,EAAS,QAMtCb,eACFoC,EAAkBvB,EAAQb,YACR,IAApBoC,IACMpC,iBACqB,IAApBoC,EAAuB,GACxBpD,SAAS,KACTgB,WACAA,WACyBa,EAAQb,iBAChC5Y,EAAI,EAAGA,EAAIqa,IAAkCra,IAC5C4Y,WAGJA,WACAhB,SAAS,SACXqD,EAAsBxB,EAAQb,SAC9BsC,EAA4BzB,EAAQb,SACpCuC,EAAmB1B,EAAQnR,SAAS,GACjB,IAArB6S,KACMvD,SAAS,KAEXtP,SAAS,GACSmR,EAAQjU,kBAEViU,EAAQb,WACPa,EAAQb,WACVa,EAAQb,WACLa,EAAQb,aAEDa,EAAQjU,cACX,IACOiU,EAAQjU,cACX,KAC1B4V,SACmB3B,EAAQjB,kBAExB,IACQ,CAAC,EAAG,cAEZ,IACQ,CAAC,GAAI,eAEb,IACQ,CAAC,GAAI,eAEb,IACQ,CAAC,GAAI,eAEb,IACQ,CAAC,GAAI,eAEb,IACQ,CAAC,GAAI,eAEb,IACQ,CAAC,GAAI,eAEb,IACQ,CAAC,GAAI,eAEb,IACQ,CAAC,GAAI,eAEb,KACQ,CAAC,GAAI,eAEb,KACQ,CAAC,GAAI,eAEb,KACQ,CAAC,GAAI,eAEb,KACQ,CAAC,IAAK,eAEd,KACQ,CAAC,EAAG,cAEZ,KACQ,CAAC,EAAG,cAEZ,KACQ,CAAC,EAAG,cAEZ,MACQ,CACRiB,EAAQjB,aAAe,EAAKiB,EAAQjB,YACpCiB,EAAQjB,aAAe,EAAKiB,EAAQjB,aAKvC4C,MACSA,EAAS,GAAKA,EAAS,WAIjC,CACL/b,MAAOgB,KAAK0I,MACmB,MAAL,GAAgC,EAAtBwR,EAAiD,EAAvBC,GAA4BG,GAE1Frb,UACO6b,MAAiD,GAAK,MACvC,EAAI,MAA2BT,KCrO3D,MAAMW,GAAiB,WAEjBC,GAA4BpE,GAAoB,CACpDA,GAAW,GACVA,GAAW,GAAM,IACjBA,GAAW,EAAK,IACP,IAAVA,GAGIqE,GAAeC,GAAiB,CAACA,EAAKC,WAAW,GAAID,EAAKC,WAAW,GAAID,EAAKC,WAAW,GAAID,EAAKC,WAAW,aAyNjH7c,yBA3CgB,CACd8c,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,GACNC,KAAM,WAMCC,KAAK5e,KAAK6e,OAAOC,SAASlf,IAC3Bmf,OAAOC,UAAUC,eAAeC,KAAKlf,KAAK6e,MAAOjf,UAC9Cif,MAAMjf,GAAQuc,GAAYvc,aAI7B+c,EAAO,IAAI1S,WAAW,CAC1B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,GACA,EACA,EACA,EACA,SAEGyS,KAAOyC,GAAaC,IAAIpf,KAAK6e,MAAMnC,KAAMyC,GAAaC,IAAIpf,KAAK6e,MAAMlC,KAAMA,eA/F/D/c,KAAgBkY,OAC7BW,EAAO,EACP7X,EAAIkX,EAAQla,aACVyhB,EAAMze,OACLA,MACA,KACGkX,EAAQlX,GAAGoF,iBAEfgE,EAAS,IAAIC,WAAWwO,SACvB,GAAMA,GAAQ,GAAM,MACpB,GAAMA,GAAQ,GAAM,MACpB,GAAMA,GAAQ,EAAK,MACnB,GAAY,IAAPA,IACLtO,IAAIvK,EAAM,GAEZgB,EAAI,EAAG6X,EAAO,EAAG7X,EAAIye,IAAOze,IAExBuJ,IAAI2N,EAAQlX,GAAI6X,MACfX,EAAQlX,GAAGoF,kBAEdgE,EA8EF+S,cACEoC,GAAaC,IAClBpf,KAAK6e,MAAM9B,KACX,IAAI9S,WAAWkS,GAAY,SAC3B,IAAIlS,WAAW,CAAC,EAAG,EAAG,EAAG,IACzB,IAAIA,WAAWkS,GAAY,SAC3B,IAAIlS,WAAWkS,GAAY,SAC3B,IAAIlS,WAAWkS,GAAY,SAC3B,IAAIlS,WAAWkS,GAAY,UAIxBoB,KAAK+B,EAAoBnf,EAAkBof,OAC5C3e,EAAI0e,EAAO1hB,aACT4hB,EAAQ,QAEP5e,MACA,IACCA,GAAKZ,KAAKse,KAAKgB,EAAO1e,WAGvBue,GAAaC,IAAIK,MACtB,KACA,CAACzf,KAAK6e,MAAMtB,KAAMvd,KAAK0d,KAAK6B,EAAWpf,IAAWia,OAAOoF,GAAOpF,OAAOpa,KAAKyd,KAAK6B,KAI9EhC,KAAKoC,EAAyBC,EAA6BC,UACzDT,GAAaC,IAAIpf,KAAK6e,MAAMvB,KAAMtd,KAAKod,KAAKsC,GAAkB1f,KAAKqe,KAAKsB,EAAqBC,IAG/F3C,KAAK9X,UACHga,GAAaC,IAAIpf,KAAK6e,MAAM5B,KAAM9X,GAGnC6X,KAAKpd,UACJuf,GAAaC,IAAIpf,KAAK6e,MAAM7B,KAAMmC,GAAaU,UAAUjgB,IAG1Dsd,KAAK0C,UACJT,GAAaC,IAClBpf,KAAK6e,MAAM3B,KACX,IAAIjT,WAAW,CACb,EACA,EACA,EACA,KACGiS,GAAyBjb,KAAK6H,MAAMgX,KAAKC,MAAQ,IAAO9D,QACxDC,GAAyBjb,KAAK6H,MAAMgX,KAAKC,MAAQ,IAAO9D,QACxDC,GAAyB0D,EAAML,cAC/BrD,GAAyB,GAC5B,GACA,IACA,EACA,KAKEiB,KAAKyC,UACJT,GAAaC,IAAIpf,KAAK6e,MAAM1B,KAAMnd,KAAKkd,KAAK0C,GAAQ5f,KAAKgd,KAAK4C,EAAMhgB,MAAOI,KAAKqd,KAAKuC,IAGtFxC,KAAK4C,UACJb,GAAaC,IAClBpf,KAAK6e,MAAMzB,KACX,IAAInT,WAAW,CACb,EACA,EACA,EACA,EACA+V,GAAkB,GACjBA,GAAkB,GAAM,IACxBA,GAAkB,EAAK,IACP,IAAjBA,KAKE3C,KAAKuC,SACQ,UAAfA,EAAMhgB,KACDuf,GAAaC,IAClBpf,KAAK6e,MAAMxB,KACX8B,GAAaC,IAAIpf,KAAK6e,MAAMF,KAAMQ,GAAaR,MAC/C3e,KAAK0c,KACL1c,KAAK4d,KAAKgC,IAGPT,GAAaC,IAClBpf,KAAK6e,MAAMxB,KACX8B,GAAaC,IAAIpf,KAAK6e,MAAMH,KAAMS,GAAaT,MAC/C1e,KAAK0c,KACL1c,KAAK4d,KAAKgC,IAINnC,KAAK6B,OACP1e,EAAI0e,EAAO1hB,aACT4hB,EAAQ,QAEP5e,MACA,IACCA,GAAKZ,KAAKwe,KAAKc,EAAO1e,WAEvBue,GAAaC,IAAIK,MAAM,KAAM,CAACzf,KAAK6e,MAAMpB,MAAMrD,OAAOoF,IAGvD9B,KAAK6B,EAAmBpf,SACxBkK,EAAQ,IAAIJ,WAAW,CAC3B,EACA,EACA,EACA,KACGiS,GAAyBjb,KAAK6H,MAAMgX,KAAKC,MAAQ,IAAO9D,QACxDC,GAAyBjb,KAAK6H,MAAMgX,KAAKC,MAAQ,IAAO9D,QACxDC,GAAyBqD,MACzBrD,GAAyB/b,GAC5B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,WAEKgf,GAAaC,IAAIpf,KAAK6e,MAAMnB,KAAMrT,GAGnCsT,KAAKiC,SACLK,EAAUL,EAAMK,SAAW,GAC3B5V,EAAQ,IAAIJ,WAAW,EAAIgW,EAAQriB,YACrCgR,EACAhO,MAGCA,EAAI,EAAGA,EAAIqf,EAAQriB,OAAQgD,MACtBqf,EAAQrf,GAAGgO,QACbhO,EAAI,GAAMgO,EAAMsR,WAAa,EAAMtR,EAAMuR,cAAgB,EAAKvR,EAAMwR,qBAGrEjB,GAAaC,IAAIpf,KAAK6e,MAAMlB,KAAMtT,GAGnCuT,KAAKgC,UACJT,GAAaC,IAClBpf,KAAK6e,MAAMjB,KACX5d,KAAK+d,KAAK6B,GACV5f,KAAKie,KAAK2B,GACV5f,KAAKyc,KAAKmD,GACV5f,KAAKke,KAAK0B,GACVT,GAAaC,IAAIpf,KAAK6e,MAAMf,KAAMqB,GAAarB,MAC/CqB,GAAaC,IAAIpf,KAAK6e,MAAMb,KAAMmB,GAAanB,MAC/CmB,GAAaC,IAAIpf,KAAK6e,MAAMhB,KAAMsB,GAAatB,OAI3CvB,KAAKsD,OAGPhf,EACAuE,EACAka,EAJA7T,EAAM,GACNC,EAAM,OAML7K,EAAI,EAAGA,EAAIgf,EAAMpU,IAAI5N,OAAQgD,MACzBgf,EAAMpU,IAAI5K,KACXuE,EAAKa,aACP5E,KAAMie,IAAQ,EAAK,OACnBje,KAAW,IAANie,KACH7T,EAAI4O,OAAO9Q,MAAM0V,UAAUxZ,MAAM0Z,KAAK/Z,QAIzCvE,EAAI,EAAGA,EAAIgf,EAAMnU,IAAI7N,OAAQgD,MACzBgf,EAAMnU,IAAI7K,KACXuE,EAAKa,aACP5E,KAAMie,IAAQ,EAAK,OACnBje,KAAW,IAANie,KACH5T,EAAI2O,OAAO9Q,MAAM0V,UAAUxZ,MAAM0Z,KAAK/Z,UAGxCkb,EAAOlB,GAAaC,IACxBpf,KAAK6e,MAAMtC,KACX,IAAItS,WACF,CACE,EACAuB,EAAI,GACJA,EAAI,GACJA,EAAI,GACJ,IACA,IAAOoU,EAAMpU,IAAI5N,QAEhBwc,OAAO5O,GACP4O,OAAO,CACNwF,EAAMnU,IAAI7N,SAEXwc,OAAO3O,MAGRxL,MAAEA,GAAU2f,GACZ1f,OAAEA,GAAW0f,SACZT,GAAaC,IAClBpf,KAAK6e,MAAMvC,KACX,IAAIrS,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACChK,GAAS,EAAK,IACP,IAARA,EACCC,GAAU,EAAK,IACP,IAATA,EACA,EACA,GACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,MAEFmgB,GAIIvD,KAAK8C,SACLU,EAAYV,EAAM9Q,OAAO9I,WACzBb,EAAO,IAAI8E,WAAW,GAAKqW,EAAY,YACxCnW,IAAI,CACP,EACA,EACA,EACA,EACA,EACA,GAAOmW,EACP,EACA,EACA,EACA,EACA,GAAOA,EACP,GACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACAA,MAEGnW,IAAIyV,EAAM9Q,OAAQ,MAClB3E,IAAI,CAAC,EAAM,EAAM,GAAO,GAAKmW,GAC3Bnb,EAGDqY,KAAKoC,SACLW,gBAAEA,GAAoBX,SACrBT,GAAaC,IAClBpf,KAAK6e,MAAMrB,KACX,IAAIvT,WAAW,CACb,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA2V,EAAMY,aACN,EACA,GACA,EACA,EACA,EACA,EAC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CA,KACGuW,GAAyBsF,EAAQ5jB,mBAE3B8jB,KAAUF,IACZpgB,QAAQ8a,GAAyBwF,WAEnCvC,GAAaC,IAAIpf,KAAK6e,MAAMX,KAAM,IAAIjU,WAAWtE,gBAz9BrDgc,GACU9B,UAAY,CACzB+B,MAAO,IAAI3X,WAAW,CACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IAEF4X,MAAO,IAAI5X,WAAW,CACpB,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,IACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,IACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,KAIW0X,GAAAG,QAAU,IAAI7X,WAAW,CACtC,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGa0X,GAAA7D,KAAOqB,GAAa2C,QAEpBH,GAAA9D,KAAOsB,GAAa2C,QAEpBH,GAAA3D,KAAO,IAAI/T,WAAW,CACnC,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGa0X,GAAAjD,KAAO,IAAIzU,WAAW,CACnC,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGa0X,GAAAhD,KAAO,IAAI1U,WAAW,CACnC,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IAGa0X,GAAA5D,KAAO,IAAI9T,WAAW,CACnC,EACA,EACA,EACA,EACA,EACA,EACA,EACA,ICvJJ,MAAM8X,GAAkB,CAACxJ,GAAK/M,IAAK+M,GAAK9M,IAAK8M,GAAKhB,IAAKgB,GAAKd,KA6C5D,IAAIuK,GAAU,WAEPxiB,4BAqDuB,CAC1B8S,GAAI2P,GAAYC,aAChBtiB,KAAM,QACNyf,IAAK,EACL8C,YAAY,EACZ3W,SAAK,EAC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"}
